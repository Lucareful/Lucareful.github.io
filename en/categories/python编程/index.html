<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python编程 | Luenci</title>
<meta name=keywords content><meta name=description content><meta name=author content="Luenci"><link rel=canonical href=https://luenci.me/en/categories/python%E7%BC%96%E7%A8%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luenci.me/images/L.png><link rel=icon type=image/png sizes=16x16 href=https://luenci.me/images/L.png><link rel=icon type=image/png sizes=32x32 href=https://luenci.me/images/L.png><link rel=apple-touch-icon href=https://luenci.me/L.png><link rel=mask-icon href=https://luenci.me/L.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://luenci.me/en/categories/python%E7%BC%96%E7%A8%8B/index.xml><link rel=alternate hreflang=en href=https://luenci.me/en/categories/python%E7%BC%96%E7%A8%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Python编程"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://luenci.me/en/categories/python%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="(〃'▽'〃)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python编程"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luenci.me/en/ accesskey=h title="Luenci (Alt + H)"><img src=https://luenci.me/images/avatar.jpg alt aria-label=logo height=35>Luenci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luenci.me/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://luenci.me/en/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://luenci.me/en/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luenci.me/en/archives title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luenci.me/en/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luenci.me/en/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luenci.me/en/links title=🤝友链><span>🤝友链</span></a></li><li><a href=https://luenci.me/en/index.xml title=📬RSS><span>📬RSS</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://luenci.me/en/>Home</a>&nbsp;»&nbsp;<a href=https://luenci.me/en/categories/>Categories</a></div><h1>Python编程</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python 中的上下文管理器</h2></header><div class=entry-content><p>with 这个关键字，对于每一学习Python的人，都不会陌生。 操作文本对象的时候，我们用 with open ，这就是一个上下文管理的例子。
1 2 with open('test.txt') as f: print f.readlines() 上下文管理器概念 基本语法
1 2 with EXPR as VAR: BLOCK 几个概念
1 2 3 1. 上下文表达式：with open('test.txt') as f: 2. 上下文管理器：open('test.txt') 3. f不是上下文管理器，应该是资源对象。 ...</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1612 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Python 中的上下文管理器" href=https://luenci.me/en/posts/python-%E4%B8%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>python之百度接口语音识别</h2></header><div class=entry-content><p>python编程之百度接口语音识别 首先在百度AI开放平台上创建语音识别应用，创建完毕应用后，得到系统分配给用户的AppID， API Key， secret Key，均为字符串，用于标识用户，为访问做签名验证。 得到验证后，开始编程 1.记录自己声音 2.将记录下来的音频文件上传至云端 3.解析返回后的结果 ...</p></div><footer class=entry-footer>1 min&nbsp;·&nbsp;433 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python之百度接口语音识别" href=https://luenci.me/en/posts/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>python多线程，并发和锁</h2></header><div class=entry-content><p>多任务 同一个时间有多个任务在执行 python程序默认是单任务 线程 线程概念 线程，可简单理解为是程序执行的一条分支，也是程序执行流的最小单元。 线程是被系统独立调度和分底的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程为其它线程共享进程所拥有的全部资源。 主线程 当一个程序后动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程，简而言之；程序后动就会创建一个主线程。
Copy主线程的重要性有两方面：
1）是产生其他子线程的线程；
2）通常它必须最后完成执行比如执行各种关闭动作·
...</p></div><footer class=entry-footer>7 min&nbsp;·&nbsp;3206 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python多线程，并发和锁" href=https://luenci.me/en/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>python的协程</h2></header><div class=entry-content><p>可迭代对象 可遍历对象就是可迭代对象 列表、元组、字典、字符串都是可迭代对象 100和自定义myclass 默认都是不可以迷代的 myclass 对象所属的类MyClass如果包含了__iter__（）方法，此时 myclass就是一个可送代对象 可送代对象的本质：对象所属的类中包含了__iter__（）方法 检测一个对象是否可以送代，用isinstance（）函数检测。 迭代器 我们发现选代器最核心的功能就是可以通过next0函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。 举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到： 特点 记录遍历的位置
...</p></div><footer class=entry-footer>8 min&nbsp;·&nbsp;3684 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python的协程" href=https://luenci.me/en/posts/%E5%8D%8F%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python的模块和类</h2></header><div class=entry-content><p>import导入模块路径问题 存在的问题：当我们把模块文件放到工程文件夹的外部的文件，发现无法正常引入模块
原因：外部的文件夹的路径，没有放到环境变量中。
查看环境变量
1.导入sys模块 2.sys.path 查看环境变量返回值是列表 把自己写的模块的路径加入到环境变量中
...</p></div><footer class=entry-footer>12 min&nbsp;·&nbsp;5901 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Python的模块和类" href=https://luenci.me/en/posts/python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E7%B1%BB/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>python的进程，线程和协程对比</h2></header><div class=entry-content><p>概念 进程 ​ 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
线程 ​ 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
协程 ​ 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
三者关系 ...</p></div><footer class=entry-footer>2 min&nbsp;·&nbsp;733 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python的进程，线程和协程对比" href=https://luenci.me/en/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%AF%B9%E6%AF%94/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>python的进程概念</h2></header><div class=entry-content><p>进程 进程概念 进程（Process）是资源分配的最小单位，是线程的容器。
程序是固定不变的，而进程会根据运行需要，让操作系统动态分配各种资源的CPU的时间片轮转，在不同的时间段切换执行不同的进程，但是切换进程是比较耗时的；就引来了轻量级进程，也就是所谓的线程，一个进程中包括多个线程（代码流，其实也就是进程中同时跑的多个方法体）
程序：例xxx.py这是程序，是一个静态的
进程：一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。
进程状态 工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态
进程状态
就绪态：运行的条件都已经满足，正在等在cpu执行 执行态：cpu正在执行其功能 等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态 进程的创建 - multiprocessing multiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。
·创建子进程跟创建线程十分类似，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start0方法后动
Process语法结构如下： Process([group [，target[，name，[args[，kwargs]]]）
target：如果传递了函数的引用，这个子进程就执行这里（函数）的代码 args：给target指定的函数传递的参数，以元组的方式传递 kwargs：给target指定的函数传递命名参数 name：给进程设定一个名字，可以不设定 group：指定进程组，大多数情况下用不到 Process创建的实例对象的常用方法：
start()：后动子进程实例（创建子进程） is_alive：判断进程子进程是否还在活着 join([timeout]）：是否等待子进程执行结束，或等待多少秒o terminate：不管任务是否完成，立即终止子进程 Process创建的实例对象的常用属性：
name：当前进程的别名，默认为Process-N，N为从1开始递增的整数 pid：当前进程的pid（进程号） linux系统可使用kill命令结束进程
...</p></div><footer class=entry-footer>9 min&nbsp;·&nbsp;4160 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python的进程概念" href=https://luenci.me/en/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>python的闭包和装饰器</h2></header><div class=entry-content><p>闭包 引入 函数名是一个特殊的变量，保存了函教的地址和 自定义一个变量可以获取函数地址 自定义变量调用函数 “函数名（）” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def work(): print("我是一个测试函数") ret = work print(ret) print("地址：%X" % id(ret)) print("地址：%X" % id(work)) ret() work() out: &lt;function work at 0x00000161E3091E18> 地址：161E3091E18 地址：161E3091E18 我是一个测试函数 我是一个测试函数 当我们定义函数test1后，函数名test1保存的是函数在内存的首地址函数名就是一个特殊的变量，函数名（）调用函数，执行函数体test1()和ret()都会调用函数，并执行函数体 和变量名一样的，函数名数名只是函数代码空间的引用，当函数名赋值给一个对象的时候就是引用传递。 闭包概念 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2165 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python的闭包和装饰器" href=https://luenci.me/en/posts/%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python类中的 私有变量 和 私有方法</h2></header><div class=entry-content><p>Python中的类 原文转自：https://blog.csdn.net/sxingming/article/details/52875125
默认情况下，Python中的成员函数和成员变量都是公开的(public),在python中没有类似public,private等关键词来修饰成员函数和成员变量。
在python中定义私有变量只需要在变量名或函数名前加上 __两个下划线，那么这个函数或变量就是私有的了。
在内部，python使用一种 name mangling 技术，将 __membername替换成 _classname__membername，也就是说，类的内部定义中,所有以双下划线开始的名字都被"翻译"成前面加上单下划线和类名的形式。
例如：为了保证不能在class之外访问私有变量，Python会在类的内部自动的把我们定义的__spam私有变量的名字替换成为 _classname__spam(注意，classname前面是一个下划线，spam前是两个下划线)，因此，用户在外部访问__spam的时候就会提示找不到相应的变量。
python中的私有变量和私有方法仍然是可以访问的
访问方法如下： 私有变量:实例._类名__变量名 私有方法:实例._类名__方法名()
其实，Python并没有真正的私有化支持，但可用下划线得到伪私有。 尽量避免定义以下划线开头的变量！
（1）_xxx “单下划线 " 开始的成员变量叫做保护变量，意思是只有类实例和子类实例能访问到这些变量， 需通过类提供的接口进行访问；不能用’from module import *‘导入 （2）__xxx 类中的私有变量/方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通。）, " 双下划线 " 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。 （3）__xxx__ 系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 __init__（）代表类的构造函数。 ...</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1561 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Python类中的 私有变量 和 私有方法" href=https://luenci.me/en/posts/python%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python类补充</h2></header><div class=entry-content><p>item系列 __getitem__ 以字典形式访问属性的时候触发 __setitem__ 以字典形式设置属性的时候触发 __delitem__ 以字典形式删除属性的时候触发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Demo(object): def __getitem__(self, item): print("触发__getitem__") def __setitem__(self, key, value): print("触发__setitem__") self.__dict__[key] = value def __delitem__(self, key): print("触发__delitem__") self.__dict__.pop(key) f = Demo() # 以字典的方式来操作属性 print(f.__dict__) f['name'] = 'luenci' print(f.__dict__) print(f['name']) del f['name'] print(f.__dict__) out: {} 触发__setitem__ {'name': 'luenci'} 触发__getitem__ None 触发__delitem__ {} __str__和__repr__控制输出 __str__会在print()打印时候调用，如果类中没重写则会调用默认的打印值，如果自定义了则会调用自定义的__str__方法 __repr__这个实在控制台的时候输出，若一个类中没定义__str__但是定义了__repr__方法，则会调用__repr__的返回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class bar(object): def __init__(self, name, age): self.name = name self.age = age # def __str__(self): # return '__str__自定义返回值' def __repr__(self): return '__repr__自定义返回值' f = bar('luenci', 18) # print() 函数触发__str__()函数 print(f) out: __repr__自定义返回值 __slots__属性 1.__slots__是什么？
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2176 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Python类补充" href=https://luenci.me/en/posts/python%E7%B1%BB%E8%A1%A5%E5%85%85/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>python解释器介绍</h2></header><div class=entry-content><p>CPython 当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。 ...</p></div><footer class=entry-footer>2 min&nbsp;·&nbsp;652 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python解释器介绍" href=https://luenci.me/en/posts/python%E8%A7%A3%E9%87%8A%E5%99%A8%E4%BB%8B%E7%BB%8D/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>python解释器的GIL锁</h2></header><div class=entry-content><p>GlL锁定义 Gll锁：Global Interpreter Lock，又称：全局解释器锁
任何Python线程执行前，必须先获得GlL锁，然后，每执行100条字节码，解释器就自动释放GL锁，让别的线程有机会执行。这个GlL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2107 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python解释器的GIL锁" href=https://luenci.me/en/posts/gil%E9%94%81/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Python面向对象</h2></header><div class=entry-content><p>类的定义 把一类事物的相同的特征和动作整合到一起就是类，类是一个抽象的概念 对象的定义 基于类而创建一个具体的事物，类的实例化 接口继承 继承的第二种含义非常重要。它又叫“接口继承”。 接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。 归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象linux的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，对底层设计者，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 导入抽象基类模块 import abc # 定义接口（基类） class File(metaclass=abc.ABCMeta): @abc.abstractmethod def read(self): pass @abc.abstractmethod def write(self): pass class disk(File): def read(self): print("disk read") def write(self): print("disk wirte") ds = disk() ds.read() 子类中调用父类的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Grandfather(object): def __init__(self, name, age): self.age = age self.name = name def grandfather(self): print("grandfather method") class Father(Grandfather): def __init__(self, name, age): super().__init__(name,age) def father_method(self): print("father method") class Son(Father): def __init__(self, name, age,sex): # 调用父类的构造方法 super().__init__(name,age) self.sex = sex # 子类中调用父类方法 def son_method(self): Father.father_method(self) def son_method1(self): super().grandfather() son1 = Son('xiaoming',18, 'male') son1.son_method1() 组合 1、组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合。 2、作用是可以将两个本来不相关的类联系起来。一般是两个类之间有显著的不同，很多时候还要附属关系(有相同的属性也有不同的属性)。比如人和头，手机和电池等等。 3、无纵向关系时用组合，有纵向关系时用继承。 4、组合就是一个类中使用到另一个类，从而把几个类拼到一起。组合的功能也是为了减少重复代码 多态 由不同的类实例化得到的对象，调用同一个方法，执行的逻辑不同 多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问，而不需考虑他们具体类。 多态表明了动态（又名，运行时）绑定的存在，允计重载及运行时类型确定和验证。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class People(object): def __init__(self, name, age): self.name = name self.age = age def generation(self): if self.age &lt; 18: print("[%s]属于未成年人" % self.name) elif 18 &lt; self.age &lt; 30: print("[%s]属于青年人" % self.name) else: print("[%s]属于中老年人" % self.name) class minor(People): pass class young(People): pass class old(People): pass def func(obj): obj.generation() w1 = young('luenci',20) w2 = minor('xiaoming', 16) w3 = old('jack', 50) func(w1) func(w3) func(w3) out: [luenci]属于青年人 [jack]属于中老年人 [jack]属于中老年人 反射 getattr(object, name) 得到属性的值 hasattr(object, name) 说明：判断对象object是否包含名为name的特性（hasattr是通过调用getattr(ojbect, name)是否抛出异常来实现的 setattr(object, name, value) 这是相对应的getattr()。参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。例如,setattr(x,“foobar”,123)相当于x.foobar= 123 delattr(object, name) 与setattr()相关的一组函数。参数是由一个对象(记住python中一切皆是对象)和一个字符串组成的。string参数必须是对象属性名之一。该函数删除该obj的一个由string指定的属性。delattr(x, 'foobar')=del x.foobar 注：getattr,hasattr,setattr,delattr对模块的修改都在内存中进行，并不会影响文件中真实内容。
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2385 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Python面向对象" href=https://luenci.me/en/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>socket网络编程实战-斗鱼弹幕获取</h2></header><div class=entry-content><p>asyncore模块 介绍 这个模块为异步socket的服务器客户端通信提供简单的接口。
该模块提供了异步socket服务客户端和服务器的基础架构。
相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而需要处理复杂的socket网络状况以及多线程处理等等。
实现流程 客户端 Socket 开发基本使用 1.定义类继承自asyncore.dispatcher
2.实现类中的回调代码
实现构造函数
调用父类方法 创建 Socket对象 连接服务器 实现handle_connect回调函数
当socket连接服务器成功时回调该函数
实现writable回调函数
描述是否有数据需要被发送到服务器。返回值为True表示可写，False表示不可写，如果不实现默认返回为True，当返回True时，回调函数handle_write将被触发
实现handle_write 回调函数
当有数据需要发送时（writable回调函数返回True时），该函数被触发，通常情况下在该函数中编写send方法发送数据
实现readable回调函数
描述是否有数据从服务端读取。返回True 表示有数据需要读取，False表示没有数据需要被读取，当不实现默认返回为True，当返回True 时，回调函数handle_read将被触发
实现handle_read 回调函数
当有数据需要读取时触发（readable回调函数返回True 时），该函数被触发，通常情况下在该函数中编写recv方法接收数据
实现handle_error回调函数
当程序运行过程发生异常时回调
实现handle_close回调函数
当连接被关闭时触发
3.创建对象并且执行asyncore.loop进入运行循环
timeout表示一次循环所需要的时长 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import asyncore import sys # 定义类继承自 asyncore.dispather class scoket_client(asyncore.dispatcher): # 实现类中的回调代码 def __init__(self, host, port): # 调用父类的方法 asyncore.dispatcher.__init__(self) # 创建 Scoket 服务器 self.create_socket() # 连接地址 address = (host, port) self.connect(address) pass # 实现handle_connect回调函数 def handle_connect(self): print("连接成功") # 实现writable函数 def writable(self): return False # 实现handle_write回调函数 def handle_write(self): # 内部实现对服务器发送数据代码 # 调用 send 方法发送数据，参数是字节数据 self.send("hello world".encode('utf-8')) # self.send("hello world") # 实现readable回调函数 def readable(self): return True # 实现handle_read回调函数 def handle_read(self): # 主动接收数据 result = self.recv(1024) print(result) # 实现handle_error回调函数 def handle_error(self): # 编写处理错误方法 t, e, trace = sys.exc_info() # 实现handle_close回调函数 def handle_close(self): print("连接关闭") self.close() # 创建对象并且执行asyncore.loop 进入循环 if __name__ == '__main__': client = scoket_client('127.0.0.1', 9000) # 开始启动运行循环 asyncore.loop(timeout=5) ...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2351 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to socket网络编程实战-斗鱼弹幕获取" href=https://luenci.me/en/posts/%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95%E6%8A%93%E5%8F%96/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>一些核心模块的介绍</h2></header><div class=entry-content><p>sys模块 模块方法 解释说明 sys.argv 传递到Python脚本的命令行参数列表，第一个元素是程序本身路径 sys.executable 返回Python解释器在当前系统中的绝对路径 sys.exit(arg) 程序中间的退出，arg=0为正常退出 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform 返回操作系统平台名称，Linux是linux2，Windows是win32 sys.stdout.write(str) 输出的时候把换行符\n去掉 val = sys.stdin.readline()[:-1] 拿到的值去掉\n换行符 sys.version 获取Python解释程序的版本信息 os模块 方法 说明 os.mkdir() 创建目录 os.rmdir() 删除目录 os.rename() 重命名 os.remove() 删除文件 os.getcwd() 获取当前工作路径 os.walk() 遍历目录 os.path.join() 连接目录与文件名 os.path.split() 分割文件名与目录 os.path.abspath() 获取绝对路径 os.path.dirname() 获取路径 os.path.basename() 获取文件名或文件夹名 os.path.splitext() 分离文件名与扩展名 os.path.isfile() 判断给出的路径是否是一个文件 os.path.isdir() 判断给出的路径是否是一个目录 json模块 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。
...</p></div><footer class=entry-footer>8 min&nbsp;·&nbsp;3974 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 一些核心模块的介绍" href=https://luenci.me/en/posts/python%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BB%8B%E7%BB%8D/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://luenci.me/en/categories/python%E7%BC%96%E7%A8%8B/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><script src=https://sdk.jinrishici.com/v2/browser/jinrishici.js></script><script type=text/javascript>jinrishici.load(function(e){var t=document.querySelector(".poem_sentence"),n=document.querySelector(".poem_info");t.innerHTML=e.data.content,n.innerHTML="—— "+e.data.origin.author})</script><span><a id=running-time></a><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>👁️‍🗨️访客人数: <span id=busuanzi_value_site_uv></span>|
🌐访问量: <span id=busuanzi_value_site_pv></span></span></span><br><span>&copy; 2024 <a href=https://luenci.me/en/>Luenci</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> 📖
<text class=poem_sentence></text><text class=poem_info></text></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});const RunningTimerInterval=1e3,StartTime=new Date("10/11/2018 00:00:00");function prefixZero(e){return e<10&&(e="0"+e),e}function updateTime(){const r=new Date;let e=r.getTime()-StartTime.getTime();const t=24*60*60*1e3,n=Math.floor(e/t);e-=n*t;const s=60*60*1e3,o=Math.floor(e/s);e-=o*s;const i=60*1e3,a=Math.floor(e/i);e-=a*i;const c=Math.floor(e/1e3),l=document.getElementById("running-time");l.innerText="🕚: "+n+"天"+prefixZero(o)+"小时"+prefixZero(a)+"分"+prefixZero(c)+"秒"}document.addEventListener("DOMContentLoaded",()=>{let e=setInterval(updateTime,RunningTimerInterval)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>