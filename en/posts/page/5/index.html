<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Luenci</title>
<meta name=keywords content><meta name=description content="Posts - Luenci"><meta name=author content="Luenci"><link rel=canonical href=https://luenci.me/en/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luenci.me/images/L.png><link rel=icon type=image/png sizes=16x16 href=https://luenci.me/images/L.png><link rel=icon type=image/png sizes=32x32 href=https://luenci.me/images/L.png><link rel=apple-touch-icon href=https://luenci.me/L.png><link rel=mask-icon href=https://luenci.me/L.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://luenci.me/en/posts/index.xml><link rel=alternate hreflang=en href=https://luenci.me/en/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://luenci.me/en/posts/"><meta property="og:site_name" content="(〃'▽'〃)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luenci.me/en/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luenci.me/en/ accesskey=h title="Luenci (Alt + H)"><img src=https://luenci.me/images/avatar.jpg alt aria-label=logo height=35>Luenci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luenci.me/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://luenci.me/en/posts title=📚文章><span class=active>📚文章</span></a></li><li><a href=https://luenci.me/en/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luenci.me/en/archives title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luenci.me/en/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luenci.me/en/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luenci.me/en/links title=🤝友链><span>🤝友链</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://luenci.me/en/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang error 处理最佳实践</h2></header><div class=entry-content><p>golang error 处理最佳实践 错误类型定义 Go 中error 类型是一个接口类型 1 2 3 type error interface { Error() string } 基本上，error 是实现该接口任何内容，它将错误消息作为字符串返回。
构造错误 ​ 可以使用 Go 的内置或包动态构造错误。
​ 例如，以下函数使用包返回带有静态错误消息的新错误：errors fmt errors
1 2 3 4 5 6 7 package main import "errors" func DoSomething() error { return errors.New("something didn't work") } ​ 同样，该包可用于向错误添加动态数据。
​ 例如：fmt int string error
1 2 3 4 5 6 7 8 9 10 package main import "fmt" func Divide(a, b int) (int, error) { if b == 0 { return 0, fmt.Errorf("can't divide '%d' by zero", a) } return a / b, nil } 请注意，当用于用格式动词包装另一个错误时，这将非常有用 fmt.Errorf %w
在上面的示例中，还有其他一些重要事项需要注意。
错误可以返回为nil ，它是 Go 中 error 的默认值或零值。这很重要，因为检查是确定是否遇到错误的惯用方法（替换您可能在其他编程语言中熟悉的 / 语句）。if err != nil 错误通常作为函数中的最后一个参数返回。因此，在上面的示例中，我们按该顺序返回 int和 nil 。 当我们返回错误时，函数返回的其他参数通常作为其默认的零值返回。函数的用户可能期望，如果返回非nil 错误，则返回的其他参数不相关。 最后，错误消息通常以小写形式编写，不以标点符号结尾。但是可以例外，例如，当包含专有名词，以大写字母开头的函数名称等。 ...</p></div><footer class=entry-footer>9 min&nbsp;·&nbsp;4119 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Golang error 处理最佳实践" href=https://luenci.me/en/posts/golang-error-%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go Project Layout 最佳实践</h2></header><div class=entry-content><p>Golang Project Layout 最佳实践 鲍勃叔叔干净的架构（Uncle Bob） 依赖规则 同心圆代表软件的不同领域。 一般来说，你走得越远，软件的层次就越高。外圈是机制。内...</p></div><footer class=entry-footer>7 min&nbsp;·&nbsp;3201 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Go Project Layout 最佳实践" href=https://luenci.me/en/posts/golang-%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go 变量声明指南</h2></header><div class=entry-content><p>golang var、:=、new、make区别及使用 ​ go里面的几大变量“类型”(不严谨，只是个人在使用的时候常用到的结构的一个划分)
（1） 值类型： int， string， struct 等 （2） 引用类型：主要是 map, slice,chan 这三个引用（make创建内存的） （3）指针类型：*int64， *struct等 var vs := ​ 对于值类型的变量，我们通过var 声明(包括结构体)，系统会默认为他分配内存空间，并赋该类型的零值。
如下，我们声明一个int类型变量i，输出为0。
1 2 var i int fmt.Println(i) // i = 0 (类型零值) var和:=之间实际上存在差异，采用:=允许重新声明变量。
与常规变量声明不同，:=声明可以重新声明变量，前提是它们最初在同一块中以相同类型声明，并且至少有一个非空白变量是新的。因此，重新声明只能出现在多变量短声明中。
重新声明不引入新变量；它只是为原始值分配一个新值。
1 2 3 4 field1, offset := nextField(str, 0) field2, offset := nextField(str, offset) // 重新声明偏移量(可重入) a, a := 1, 2 // 非法：如果在别处声明了 a，则双重声明 a 或没有新变量 所以我会说:=运算符不是纯粹的声明，而是更像声明和分配。不允许在顶层重新声明，因此也不允许短声明。另一个原因可能是语法简单。type在 Go 中，所有顶级表单都以var 或 func 开头。
建议：重复声明的变量用 :=，比如 err 的声明，使用的值或全局变量（不推荐大量使用）用 var， 如 var fields []string
...</p></div><footer class=entry-footer>3 min&nbsp;·&nbsp;1291 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Go 变量声明指南" href=https://luenci.me/en/posts/%E6%B5%85%E6%9E%90-golangmakenewvar%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>服务配置和热更新</h2></header><div class=entry-content><p>程序配置服务和热更新 前言 ​ 在开发过程中，因为不同环境中有不同的配置，所以往往一个项目要同时保存着不同环境的配置文件（dev，test，staging，prd）等。如果没有一个方便简洁的管理这些配置文件方式，排查问题也会变的麻烦。接下来介绍几种我所经历的几种配置文件管理方案
git 分支管理 ​ 顾名思义就是利用 git 的分支来管理不同环境的配置，比如dev分支就是对应存放这dev的配置文件。
优点 分支管理更符合开发的代码习惯，只关心本分支的代码和配置 缺点 不符合git-flow流程，如果test配置有改动，那么就要直接编辑test分支代码，而不是从dev分支合并过去。排查配置相关问题不友善 一份配置文件就一个分支，维护代价太大，有些舍本琢末了。 热更新方案无 所有配置文件都放在项目下 ​ 这种方式就是把所有的配置文件集中放在项目下的某个目录，用环境变量的方式去加载指定的配置文件
1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main func main(){ switch env{ case:"dev": load("dev.config") case:"test": load("test.config") ... default: load("local.config") } } 优点 配置统一集中管理，修改方便 缺点 配置文件过多容易使项目结构变的“难看”，判断依赖过多，不优雅。 无法做到热更新，配置更改需要重新发布代码 热更新方案无 配置中心 ​ 将配置文件都放到三方的服务中保管，比如nacos、Apollo等配置中心
nacos：https://nacos.io/zh-cn/docs/what-is-nacos.html Apollo：https://www.apolloconfig.com/#/zh/README 优点 集中化管理配置，配置文件“不落地” 有相关 sdk 调用，支持热更新等高级功能 缺点 要维护一个高可用的 三方服务 增加了维护成本 热更新方案 需要另外编码去开发 ...</p></div><footer class=entry-footer>3 min&nbsp;·&nbsp;1342 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 服务配置和热更新" href=https://luenci.me/en/posts/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Golang Sync.Once 的探究</h2></header><div class=entry-content><p>sync.Once 的用法 ​ 在多数情况下，sync.Once 被用于控制变量的初始化，这个变量的读写通常遵循单例模式，满足这三个条件：
当且仅当第一次读某个变量时，进行初始化（写操作） 变量被初始化过程中，所有读都被阻塞（读操作；当变量初始化完成后，读操作继续进行） 变量仅初始化一次，初始化完成后驻留在内存里 实例化一次客户端 ​ 在标准库中不乏有大量 sync.Once 的使用案例，在 strings 包中 replace.go 里实现字符串批量替换功能时，需要预编译生成替换规则，即采用不同的替换算法并创建相关算法实例，因 strings.Replacer 实现是线程安全且支持规则复用，在第一次解析替换规则并创建对应算法实例后，可以并发的进行字符串替换操作，避免多次解析替换规则浪费资源。
先看一下 strings.Replacer 的结构定义：
1 2 3 4 5 6 // source: strings/replace.go type Replacer struct { once sync.Once // guards buildOnce method r replacer oldnew []string } ​ 这里定义了 once sync.Once 用来控制 r replacer 替换算法初始化，当我们使用 strings.NewReplacer 创建 strings.Replacer 时，这里采用惰性算法，并没有在这时进行 build 解析替换规则并创建对应算法实例，而是在执行替换时( Replacer.Replace 和 Replacer.WriteString)进行的, r.once.Do(r.buildOnce) 使用 sync.Once 的 Do 方法保证只有在首次执行时才会执行 buildOnce 方法，而在 buildOnce 中调用 build 解析替换规则并创建对应算法实例，在 buildOnce 中进行赋值。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // source: strings/replace.go func NewReplacer(oldnew ...string) *Replacer { if len(oldnew)%2 == 1 { panic("strings.NewReplacer: odd argument count") } return &amp;Replacer{oldnew: append([]string(nil), oldnew...)} } func (r *Replacer) buildOnce() { r.r = r.build() r.oldnew = nil } func (b *Replacer) build() replacer { .... } func (r *Replacer) Replace(s string) string { r.once.Do(r.buildOnce) return r.r.Replace(s) } func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error) { r.once.Do(r.buildOnce) return r.r.WriteString(w, s) } ​ 简单来说，once.Do 中的函数只会执行一次，并保证 once.Do 返回时，传入 Do 的函数已经执行完成。多个 goroutine 同时执行 once.Do 的时候，可以保证抢占到 once.Do 执行权的 goroutine 执行完 once.Do 后，其他 goroutine 才能得到返回。
​ once.Do 接收一个函数作为参数，该函数不接受任何参数，不返回任何参数。具体做什么由使用方决定，错误处理也由使用方控制，对函数初始化的结果也由使用方进行保存。
...</p></div><footer class=entry-footer>2 min&nbsp;·&nbsp;1001 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Golang Sync.Once 的探究" href=https://luenci.me/en/posts/sync.once-%E7%9A%84%E6%8E%A2%E7%A9%B6/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>go get 私有库解决方案</h2></header><div class=entry-content><p>golang go get 私有库解决方案 注意：go get 只支持 https协议的库路径 ‼️
前言 ​ 在我们开发过程中会自己封装一些工具库，在某个项目中使用。但是如果有别的项目想使用你封装的库，那么此时你就需要将工具库封装为一个go module，给其它项目导入。一般公司内部的库是不对外开放的，这时候就需要搭建代理去拉取私有仓库
原理架构图 ...</p></div><footer class=entry-footer>2 min&nbsp;·&nbsp;768 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to go get 私有库解决方案" href=https://luenci.me/en/posts/golang-go-get-%E7%A7%81%E6%9C%89%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>聊聊链路追踪 OpenTracing</h2></header><div class=entry-content><p>聊聊链路追踪 OpenTracing 什么是 Tracing 对 Tracing 的定义是，在软件工程中，Tracing 指使用特定的日志记录程序的执行信息，与之相近的还有两个概念，它们分别是 Logging 和 Metrics。
Logging：用于记录离散的事件，包含程序执行到某一点或某一阶段的详细信息。 Metrics：可聚合的数据，且通常是固定类型的时序数据，包括 Counter、Gauge、Histogram 等。 Tracing：记录单个请求的处理流程，其中包括服务调用和处理时长等信息。 同时这三种定义相交的情况也比较常见。
Logging & Metrics：可聚合的事件。例如分析某对象存储的 Nginx 日志，统计某段时间内 GET、PUT、DELETE、OPTIONS 操作的总数。 Metrics & Tracing：单个请求中的可计量数据。例如 SQL 执行总时长、gRPC 调用总次数。 Tracing & Logging：请求阶段的标签数据。例如在 Tracing 的信息中标记详细的错误原因。 针对每种分析需求，我们都有非常强大的集中式分析工具。
Logging：ELK，近几年势头最猛的日志分析服务，无须多言。
Metrics：Prometheus，第二个加入 CNCF 的开源项目，非常好用。
Tracing：OpenTracing 和 Jaeger，Jaeger 是 Uber 开源的一个兼容 OpenTracing 标准的分布式追踪服务。目前 Jaeger 也加入了 CNCF。
原理 ​ 分布式追踪系统大体分为三个部分，数据采集、数据持久化、数据展示。数据采集是指在代码中埋点，设置请求中要上报的阶段，以及设置当前记录的阶段隶属于哪个上级阶段。数据持久化则是指将上报的数据落盘存储，例如 Jaeger 就支持多种存储后端，可选用 Cassandra 或者 Elasticsearch。数据展示则是前端根据 Trace ID 查询与之关联的请求阶段，并在界面上呈现。
上图是一个请求的流程例子，请求从客户端发出，到达负载均衡，再依次进行认证、计费，最后取到目标资源。
请求过程被采集之后，会以上图的形式呈现，横坐标是时间，圆角矩形是请求的执行的各个阶段。
...</p></div><footer class=entry-footer>11 min&nbsp;·&nbsp;5147 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 聊聊链路追踪 OpenTracing" href=https://luenci.me/en/posts/%E8%81%8A%E8%81%8A%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA-opentracing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GO 代码风格指南</h2></header><div class=entry-content><p>GO 代码风格指南 风格原则 ​ 有一些总体原则总结了如何考虑编写可读的 Go 代码。以下是可读代码的属性，按重要性排序：
清晰：代码的目的和基本原理对读者来说是清楚的。 简单性：代码以尽可能简单的方式实现其目标。 简洁：代码具有高信噪比。 可维护性：代码的编写使其易于维护。 一致性：代码与更广泛的 Google 代码库一致。 ...</p></div><footer class=entry-footer>23 min&nbsp;·&nbsp;11159 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to GO 代码风格指南" href=https://luenci.me/en/posts/golang%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Giweights 介绍</h2></header><div class=entry-content><p>Giweights 介绍 https://icloudnative.io/posts/what-is-giweights/
基础设施即代码 在理解 Giweights 之前，我们需要先理解什么是基础设施即代码。
基础设施即代码（Infrastructure as Code, IaC），顾名思义，表示使用代码（而非手动流程）来定义基础设施，研发人员可以像对待应用软件一样对待基础设施，例如：
可以创建包含基础架构规范的声明式配置文件，从而便于编辑和分发配置。 可以确保每次配置的环境都完全相同。 可以进行版本控制，所有的变更都会被记录下来，方便溯源。 可以将基础设施划分为若干个模块化组件，并通过自动化以不同的方式进行组合。 当然，广义上的 IaC 不仅仅只关于基础设施，还包含了网络、安全、配置等等，所以广义上的 IaC 又叫 X as Code。
​ 比如你想在 AWS 中创建服务器，配置网络，部署 Kubernetes 集群以及各种工作负载，你只需要定义好 Terraform 或 Ansible 的声明式配置，以及 Kubernetes 的配置清单即可，免去一切繁杂的手动操作。
Giweights 是什么 ​ Giweights = IaC + Git + CI/CD，即基于 IaC 的版本化 CI/CD。它的核心是使用 Git 仓库来管理基础设施和应用的配置，并且以 Git 仓库作为基础设施和应用的单一事实来源，你从其他地方修改配置（比如手动改线上配置）一概不予通过。
​ Git 仓库中的声明式配置描述了目标环境当前所需基础设施的期望状态，借助于 Giweights，如果集群的实际状态与 Git 仓库中定义的期望状态不匹配，Kubernetes reconcilers 会根据期望状态来调整当前的状态，最终使实际状态符合期望状态。
​ 另一方面，现代应用的开发更多关注的是迭代速度和规模，拥有成熟 DevOps 文化的组织每天可以将代码部署到生成环境中数百次，DevOps 团队可以通过版本控制、代码审查以及自动测试和部署的 CI/CD 流水线等最佳实践来实现这一目标，这就是 Giweights 干的事情。
Giweights vs DevOps ​ 从广义上来看，Giweights 与 DevOps 并不冲突，Giweights 是一种技术手段，而 DevOps 是一种文化。Giweights 是一种实现持续交付（Continuous Delivery）、持续部署（Continuous Deployment）和基础设施即代码（IaC）的工具和框架，它是支持 DevOps 文化的。
从狭义上来看，Giweights 与 DevOps 有以下几个区别：
​ 首先，Giweights 是以目标为导向的。它使用 Git 来维护期望状态，并不断调整实际状态，最终与期望状态相匹配。而 DevOps 更多关注的是最佳实践，这些实践可以普遍应用于企业的每一个流程。
​ 其次，Giweights 采取声明式的操作方法，而 DevOps 同时接受声明式和命令式的方法，所以 DevOps 除了适用于容器环境之外，还适用于虚拟机和裸机环境。
​ 最后，Giweights 重新定义了云原生场景下的 CI/CD，它以 Git 作为中心的不可变状态声明，以加快持续部署速度。
...</p></div><footer class=entry-footer>6 min&nbsp;·&nbsp;2986 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Giweights 介绍" href=https://luenci.me/en/posts/gitops-%E5%8E%9F%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django的logger配置</h2></header><div class=entry-content><p>Django日志配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'verbose': { 'format': '%(levelname)s %(asctime)s %(pathname)s %(module)s %(lineno)s %(process)d %(thread)d %(message)s' } }, 'loggers': { 'django': { 'handlers': ['default'], 'propagate': True, 'level': 'DEBUG', 'filters': ['special'] } }, 'handlers': { 'default': { 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'filename': '/var/logs/django/default.log', 'maxBytes': 1024 * 1024 * 5, 'backupCount': 5, 'formatter': 'verbose', 'filters': ['special'] } }, 'filters': { # 过滤器 'special': { # 使用自定义的web.my_logging.ContextFilter，别名special，可以接受其他的参数 '()': 'web.my_logging.ContextFilter' } }, } 配置分析说明 version 保留字。
disable_existing_loggers 是否禁用已经存在的logger实例。
如果LOGGING 中的disable_existing_loggers 键为True（默认值），那么默认配置中的所有logger 都将禁用。
Logger 的禁用与删除不同；logger 仍然存在，但是将默默丢弃任何传递给它的信息，也不会传播给上一级logger。所以，你应该非常小心使用'disable_existing_loggers': True；它可能不是你想要的。你可以设置disable_existing_loggers 为False，并重新定义部分或所有的默认loggers；或者你可以设置LOGGING_CONFIG 为 None，并 自己处理logging 配置。
Logging 的配置属于Django setup() 函数的一部分。所以，你可以肯定在你的项目代码中logger 是永远可用的。
formatters 定义输出的日志格式。 常用的格式化属性：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 %(name)s Logger的名字 %(levelname)s 文本形式的日志级别 %(message)s 用户输出的消息 %(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒 %(levelno)s 数字形式的日志级别 %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有 %(filename)s 调用日志输出函数的模块的文件名 %(module)s 调用日志输出函数的模块名 %(funcName)s 调用日志输出函数的函数名 %(lineno)d 调用日志输出函数的语句所在的代码行 %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示 %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数 %(thread)d 线程ID。可能没有 %(threadName)s 线程名。可能没有 %(process)d 进程ID。可能没有 其他格式化属性请参 LogRecord attributes
...</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1840 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Django的logger配置" href=https://luenci.me/en/posts/django%E7%9A%84logger/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet。 一、QuerySet何时被提交 在内部，创建、过滤、切片和传递一个Que...</p></div><footer class=entry-footer>26 min&nbsp;·&nbsp;12928 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to " href=https://luenci.me/en/posts/django%E7%9A%84queryset%E8%AF%A6%E8%A7%A3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Golang 的值传递 先导文章：（正经版）面试官：切片作为函数参数是传值还是传引用？ Go语言中的 new 和 make 主要区别如下： make 只能用来分配及初始化类型为 slic...</p></div><footer class=entry-footer>3 min&nbsp;·&nbsp;1135 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to " href=https://luenci.me/en/posts/golang%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>12306自动化抢票实现</h2></header><div class=entry-content><p>selenium常用API find_element_by_xxx 返回第一个符合条件WebElement元素 find_elements_by_xxx 返回符合条件所有元素包含了 WebEelemnt 列表 函数 作用 find_element_by_class_name 通过class查询元素 find_element_by_id 通过ID查询元素 find_element_by_name 通过name查询元素 find_element_by_tag_name 通过标签名称 find_element_by_css_selector css样式选择 find_element_by_link_text 通过链接内容查找 find_element_by_partial_link_text 通过链接内容包含的内容查找，模糊查询 find_element_by_xpath 通过xpath查找数据 获取元素属性和文本内容 1 2 3 4 5 6 7 8 #获取属性 element.get_attribute（'属性名”） #获取文本内容 element.text # 输入框输入内容 input_element.send_keys（'Luenci'） # 元素点击 element.click() 三种等待方式 当控制浏览器时，浏览器正在加载页面同时又去获取数据导致浏览器寻找不到需要操作的元素引发异常。 方式一：强制等待，浪费时间 time.sleep（秒数） 方式二：隐性等待，无法控制Ajax请求 browser.implicit1y_wait（等待时间） 方式三：显性等待，每个元素都可以自己定义检查条件。手动编写方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #显性等待-手动编写 t = time.time（） #定义超时时间 timeout = 60 while True： try： #超时时间间隔 time.sleep（0.1） ur1_element = browser.find_element_by_class_name（"fav ur1"） break except： #超时处理 if time.time（）- t > timeout： break pass 系统提供显性等待API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 导入显性等待的API需要的模块 # 1等待对象模块 from selenium.webdriver.support.wait import WebDriverwait # 2导入等待条件模块 from selenium.webdriver.support import expected_conditions as EC # 3导入查询元素模块 from selenium.webdriver.common.by import By # 1.创建等待对象 # 参数一浏览器对象 # 参数二超时时间 # 参数三检查元素时间间隔 wait = WebDriverwait（browser，5.0，0.5） # 2.通过等待对象获取元素 # presence_of_element_located 检查元素是否存在，如果存在就返回如果不存在就继续检查 # visibility_of_element_located 检查元素是否可见 linkelement = s wait.until（EC.presence_of_element_located（（By.CLASS_NAME，"favurl"） link_element.click（） 12306爬虫实现 完成代码见：https://github.com/Lucareful/12306_Tickets
实现步骤 1.访问列表页 2.通过时间判定选择点击预订 3.点击账号登录 4.输入用户名和密码（15523750230） 5.截图获取验证码图片 6.发送打码平台获取识别数字 7.定义8个点击坐标 8.模拟点击坐标 9.点击登录 10.点击选择人物 11.点击提交订单 12.点击确认订单 ...</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1773 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 12306自动化抢票实现" href=https://luenci.me/en/posts/12306%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%A5%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C 语言中 void* 详解及应用</h2></header><div class=entry-content><p>C 语言中 void* 详解及应用 void 在英文中作为名词的解释为 “空虚、空间、空隙”，而在 C 语言中，void 被翻译为**“无类型”，相应的void *** 为**“无类型指针”**。
void 似乎只有"注释"和限制程序的作用，当然，这里的"注释"不是为我们人提供注释，而是为编译器提供一种所谓的注释。
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2101 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to C 语言中 void* 详解及应用" href=https://luenci.me/en/posts/c-%E8%AF%AD%E8%A8%80%E4%B8%AD-void-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cookie和Session知识</h2></header><div class=entry-content><p>参考： https://juejin.im/post/5aa783b76fb9a028d663d70a https://www.cnblogs.com/wj-1314/p/10496253.html Session是存储在服务器端的，Cookie是存储在客户端的 Cookie的概念 Cookie是客户端用户信息的一种机制，用来记录用...</p></div><footer class=entry-footer>7 min&nbsp;·&nbsp;3219 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Cookie和Session知识" href=https://luenci.me/en/posts/django%E7%9A%84cookie%E5%92%8Csession/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://luenci.me/en/posts/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://luenci.me/en/posts/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span><a id=running-time></a><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>👁️‍🗨️访客人数: <span id=busuanzi_value_site_uv></span>|
🌐访问量: <span id=busuanzi_value_site_pv></span></span></span><br><span>&copy; 2024 <a href=https://luenci.me/en/>Luenci</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});const RunningTimerInterval=1e3,StartTime=new Date("10/11/2018 00:00:00");function prefixZero(e){return e<10&&(e="0"+e),e}function updateTime(){const r=new Date;let e=r.getTime()-StartTime.getTime();const t=24*60*60*1e3,n=Math.floor(e/t);e-=n*t;const s=60*60*1e3,o=Math.floor(e/s);e-=o*s;const i=60*1e3,a=Math.floor(e/i);e-=a*i;const c=Math.floor(e/1e3),l=document.getElementById("running-time");l.innerText="🕚: "+n+"天"+prefixZero(o)+"小时"+prefixZero(a)+"分"+prefixZero(c)+"秒"}document.addEventListener("DOMContentLoaded",()=>{let e=setInterval(updateTime,RunningTimerInterval)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>