<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Luenci</title>
<meta name=keywords content><meta name=description content="Posts - Luenci"><meta name=author content="Luenci"><link rel=canonical href=https://luenci.com/en/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luenci.com/images/L.png><link rel=icon type=image/png sizes=16x16 href=https://luenci.com/images/L.png><link rel=icon type=image/png sizes=32x32 href=https://luenci.com/images/L.png><link rel=apple-touch-icon href=https://luenci.com/L.png><link rel=mask-icon href=https://luenci.com/L.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://luenci.com/en/posts/index.xml><link rel=alternate hreflang=en href=https://luenci.com/en/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://umami.luenci.com/script.js data-website-id=b0a9e971-b470-43a2-bda9-182c654377f4></script><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://luenci.com/en/posts/"><meta property="og:site_name" content="(〃'▽'〃)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luenci.com/en/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luenci.com/en/ accesskey=h title="Luenci (Alt + H)"><img src=https://luenci.com/images/avatar.jpg alt aria-label=logo height=35>Luenci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luenci.com/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://luenci.com/en/posts title=📚文章><span class=active>📚文章</span></a></li><li><a href=https://luenci.com/en/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luenci.com/en/archives title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luenci.com/en/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luenci.com/en/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luenci.com/en/links title=🤝友链><span>🤝友链</span></a></li><li><a href=https://luenci.com/en/index.xml title=📬RSS><span>📬RSS</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://luenci.com/en/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>go get 私有库解决方案</h2></header><div class=entry-content><p>golang go get 私有库解决方案 注意：go get 只支持 https协议的库路径 ‼️
前言 ​ 在我们开发过程中会自己封装一些工具库，在某个项目中使用。但是如果有别的项目想使用你封装的库，那么此时你就需要将工具库封装为一个go module，给其它项目导入。一般公司内部的库是不对外开放的，这时候就需要搭建代理去拉取私有仓库
原理架构图 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 2 min&nbsp|&nbsp📖字数: 768 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to go get 私有库解决方案" href=https://luenci.com/en/posts/golang-go-get-%E7%A7%81%E6%9C%89%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>聊聊链路追踪 OpenTracing</h2></header><div class=entry-content><p>聊聊链路追踪 OpenTracing 什么是 Tracing 对 Tracing 的定义是，在软件工程中，Tracing 指使用特定的日志记录程序的执行信息，与之相近的还有两个概念，它们分别是 Logging 和 Metrics。
Logging：用于记录离散的事件，包含程序执行到某一点或某一阶段的详细信息。 Metrics：可聚合的数据，且通常是固定类型的时序数据，包括 Counter、Gauge、Histogram 等。 Tracing：记录单个请求的处理流程，其中包括服务调用和处理时长等信息。 同时这三种定义相交的情况也比较常见。
Logging & Metrics：可聚合的事件。例如分析某对象存储的 Nginx 日志，统计某段时间内 GET、PUT、DELETE、OPTIONS 操作的总数。 Metrics & Tracing：单个请求中的可计量数据。例如 SQL 执行总时长、gRPC 调用总次数。 Tracing & Logging：请求阶段的标签数据。例如在 Tracing 的信息中标记详细的错误原因。 针对每种分析需求，我们都有非常强大的集中式分析工具。
Logging：ELK，近几年势头最猛的日志分析服务，无须多言。
Metrics：Prometheus，第二个加入 CNCF 的开源项目，非常好用。
Tracing：OpenTracing 和 Jaeger，Jaeger 是 Uber 开源的一个兼容 OpenTracing 标准的分布式追踪服务。目前 Jaeger 也加入了 CNCF。
原理 ​ 分布式追踪系统大体分为三个部分，数据采集、数据持久化、数据展示。数据采集是指在代码中埋点，设置请求中要上报的阶段，以及设置当前记录的阶段隶属于哪个上级阶段。数据持久化则是指将上报的数据落盘存储，例如 Jaeger 就支持多种存储后端，可选用 Cassandra 或者 Elasticsearch。数据展示则是前端根据 Trace ID 查询与之关联的请求阶段，并在界面上呈现。
上图是一个请求的流程例子，请求从客户端发出，到达负载均衡，再依次进行认证、计费，最后取到目标资源。
请求过程被采集之后，会以上图的形式呈现，横坐标是时间，圆角矩形是请求的执行的各个阶段。
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 11 min&nbsp|&nbsp📖字数: 5147 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 聊聊链路追踪 OpenTracing" href=https://luenci.com/en/posts/%E8%81%8A%E8%81%8A%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA-opentracing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GO 代码风格指南</h2></header><div class=entry-content><p>GO 代码风格指南 风格原则 ​ 有一些总体原则总结了如何考虑编写可读的 Go 代码。以下是可读代码的属性，按重要性排序：
清晰：代码的目的和基本原理对读者来说是清楚的。 简单性：代码以尽可能简单的方式实现其目标。 简洁：代码具有高信噪比。 可维护性：代码的编写使其易于维护。 一致性：代码与更广泛的 Google 代码库一致。 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 23 min&nbsp|&nbsp📖字数: 11159 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to GO 代码风格指南" href=https://luenci.com/en/posts/golang%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Giweights 介绍</h2></header><div class=entry-content><p>Giweights 介绍 https://icloudnative.io/posts/what-is-giweights/
基础设施即代码 在理解 Giweights 之前，我们需要先理解什么是基础设施即代码。
基础设施即代码（Infrastructure as Code, IaC），顾名思义，表示使用代码（而非手动流程）来定义基础设施，研发人员可以像对待应用软件一样对待基础设施，例如：
可以创建包含基础架构规范的声明式配置文件，从而便于编辑和分发配置。 可以确保每次配置的环境都完全相同。 可以进行版本控制，所有的变更都会被记录下来，方便溯源。 可以将基础设施划分为若干个模块化组件，并通过自动化以不同的方式进行组合。 当然，广义上的 IaC 不仅仅只关于基础设施，还包含了网络、安全、配置等等，所以广义上的 IaC 又叫 X as Code。
​ 比如你想在 AWS 中创建服务器，配置网络，部署 Kubernetes 集群以及各种工作负载，你只需要定义好 Terraform 或 Ansible 的声明式配置，以及 Kubernetes 的配置清单即可，免去一切繁杂的手动操作。
Giweights 是什么 ​ Giweights = IaC + Git + CI/CD，即基于 IaC 的版本化 CI/CD。它的核心是使用 Git 仓库来管理基础设施和应用的配置，并且以 Git 仓库作为基础设施和应用的单一事实来源，你从其他地方修改配置（比如手动改线上配置）一概不予通过。
​ Git 仓库中的声明式配置描述了目标环境当前所需基础设施的期望状态，借助于 Giweights，如果集群的实际状态与 Git 仓库中定义的期望状态不匹配，Kubernetes reconcilers 会根据期望状态来调整当前的状态，最终使实际状态符合期望状态。
​ 另一方面，现代应用的开发更多关注的是迭代速度和规模，拥有成熟 DevOps 文化的组织每天可以将代码部署到生成环境中数百次，DevOps 团队可以通过版本控制、代码审查以及自动测试和部署的 CI/CD 流水线等最佳实践来实现这一目标，这就是 Giweights 干的事情。
Giweights vs DevOps ​ 从广义上来看，Giweights 与 DevOps 并不冲突，Giweights 是一种技术手段，而 DevOps 是一种文化。Giweights 是一种实现持续交付（Continuous Delivery）、持续部署（Continuous Deployment）和基础设施即代码（IaC）的工具和框架，它是支持 DevOps 文化的。
从狭义上来看，Giweights 与 DevOps 有以下几个区别：
​ 首先，Giweights 是以目标为导向的。它使用 Git 来维护期望状态，并不断调整实际状态，最终与期望状态相匹配。而 DevOps 更多关注的是最佳实践，这些实践可以普遍应用于企业的每一个流程。
​ 其次，Giweights 采取声明式的操作方法，而 DevOps 同时接受声明式和命令式的方法，所以 DevOps 除了适用于容器环境之外，还适用于虚拟机和裸机环境。
​ 最后，Giweights 重新定义了云原生场景下的 CI/CD，它以 Git 作为中心的不可变状态声明，以加快持续部署速度。
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 6 min&nbsp|&nbsp📖字数: 2986 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Giweights 介绍" href=https://luenci.com/en/posts/gitops-%E5%8E%9F%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django的logger配置</h2></header><div class=entry-content><p>Django日志配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'verbose': { 'format': '%(levelname)s %(asctime)s %(pathname)s %(module)s %(lineno)s %(process)d %(thread)d %(message)s' } }, 'loggers': { 'django': { 'handlers': ['default'], 'propagate': True, 'level': 'DEBUG', 'filters': ['special'] } }, 'handlers': { 'default': { 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', 'filename': '/var/logs/django/default.log', 'maxBytes': 1024 * 1024 * 5, 'backupCount': 5, 'formatter': 'verbose', 'filters': ['special'] } }, 'filters': { # 过滤器 'special': { # 使用自定义的web.my_logging.ContextFilter，别名special，可以接受其他的参数 '()': 'web.my_logging.ContextFilter' } }, } 配置分析说明 version 保留字。
disable_existing_loggers 是否禁用已经存在的logger实例。
如果LOGGING 中的disable_existing_loggers 键为True（默认值），那么默认配置中的所有logger 都将禁用。
Logger 的禁用与删除不同；logger 仍然存在，但是将默默丢弃任何传递给它的信息，也不会传播给上一级logger。所以，你应该非常小心使用'disable_existing_loggers': True；它可能不是你想要的。你可以设置disable_existing_loggers 为False，并重新定义部分或所有的默认loggers；或者你可以设置LOGGING_CONFIG 为 None，并 自己处理logging 配置。
Logging 的配置属于Django setup() 函数的一部分。所以，你可以肯定在你的项目代码中logger 是永远可用的。
formatters 定义输出的日志格式。 常用的格式化属性：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 %(name)s Logger的名字 %(levelname)s 文本形式的日志级别 %(message)s 用户输出的消息 %(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒 %(levelno)s 数字形式的日志级别 %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有 %(filename)s 调用日志输出函数的模块的文件名 %(module)s 调用日志输出函数的模块名 %(funcName)s 调用日志输出函数的函数名 %(lineno)d 调用日志输出函数的语句所在的代码行 %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示 %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数 %(thread)d 线程ID。可能没有 %(threadName)s 线程名。可能没有 %(process)d 进程ID。可能没有 其他格式化属性请参 LogRecord attributes
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 4 min&nbsp|&nbsp📖字数: 1840 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Django的logger配置" href=https://luenci.com/en/posts/django%E7%9A%84logger/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet。
一、QuerySet何时被提交 在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。可以使用下列方法对QuerySet提交查询操作： 迭代 QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的headline打印出来： 1 2 for e in Entry.objects.all(): print(e.headline) 切片：如果使用切片的”step“参数，Django 将执行数据库查询并返回一个列表。 Pickling/缓存 repr()
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 26 min&nbsp|&nbsp📖字数: 12928 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to " href=https://luenci.com/en/posts/django%E7%9A%84queryset%E8%AF%A6%E8%A7%A3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Golang 的值传递 先导文章：（正经版）面试官：切片作为函数参数是传值还是传引用？
Go语言中的 new 和 make 主要区别如下：
make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据； new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type； new 分配的空间被清零。make 分配空间后，会进行初始化； 传入参数和传出参数 传入参数为本身有值，传入函数让函数使用；传出参数本身没值，从函数中带出值（相当于函数的返回值）。 函数参数为指针 将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中传指针也是传值。
传值 当我们验证了 Go 语言中大多数常见的数据结构之后，其实能够推测出 Go 语言在传递参数时使用了传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。
函数小结 通过堆栈传递参数，入栈的顺序是从右到左，而参数的计算是从左到右； 函数返回值通过堆栈传递并由调用者预先分配内存空间； 调用函数时都是传值，接收方会对入参进行复制再计算； ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 3 min&nbsp|&nbsp📖字数: 1135 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to " href=https://luenci.com/en/posts/golang%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>12306自动化抢票实现</h2></header><div class=entry-content><p>selenium常用API find_element_by_xxx 返回第一个符合条件WebElement元素 find_elements_by_xxx 返回符合条件所有元素包含了 WebEelemnt 列表 函数 作用 find_element_by_class_name 通过class查询元素 find_element_by_id 通过ID查询元素 find_element_by_name 通过name查询元素 find_element_by_tag_name 通过标签名称 find_element_by_css_selector css样式选择 find_element_by_link_text 通过链接内容查找 find_element_by_partial_link_text 通过链接内容包含的内容查找，模糊查询 find_element_by_xpath 通过xpath查找数据 获取元素属性和文本内容 1 2 3 4 5 6 7 8 #获取属性 element.get_attribute（'属性名”） #获取文本内容 element.text # 输入框输入内容 input_element.send_keys（'Luenci'） # 元素点击 element.click() 三种等待方式 当控制浏览器时，浏览器正在加载页面同时又去获取数据导致浏览器寻找不到需要操作的元素引发异常。 方式一：强制等待，浪费时间 time.sleep（秒数） 方式二：隐性等待，无法控制Ajax请求 browser.implicit1y_wait（等待时间） 方式三：显性等待，每个元素都可以自己定义检查条件。手动编写方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #显性等待-手动编写 t = time.time（） #定义超时时间 timeout = 60 while True： try： #超时时间间隔 time.sleep（0.1） ur1_element = browser.find_element_by_class_name（"fav ur1"） break except： #超时处理 if time.time（）- t > timeout： break pass 系统提供显性等待API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 导入显性等待的API需要的模块 # 1等待对象模块 from selenium.webdriver.support.wait import WebDriverwait # 2导入等待条件模块 from selenium.webdriver.support import expected_conditions as EC # 3导入查询元素模块 from selenium.webdriver.common.by import By # 1.创建等待对象 # 参数一浏览器对象 # 参数二超时时间 # 参数三检查元素时间间隔 wait = WebDriverwait（browser，5.0，0.5） # 2.通过等待对象获取元素 # presence_of_element_located 检查元素是否存在，如果存在就返回如果不存在就继续检查 # visibility_of_element_located 检查元素是否可见 linkelement = s wait.until（EC.presence_of_element_located（（By.CLASS_NAME，"favurl"） link_element.click（） 12306爬虫实现 完成代码见：https://github.com/Lucareful/12306_Tickets
实现步骤 1.访问列表页 2.通过时间判定选择点击预订 3.点击账号登录 4.输入用户名和密码（15523750230） 5.截图获取验证码图片 6.发送打码平台获取识别数字 7.定义8个点击坐标 8.模拟点击坐标 9.点击登录 10.点击选择人物 11.点击提交订单 12.点击确认订单 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 4 min&nbsp|&nbsp📖字数: 1773 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 12306自动化抢票实现" href=https://luenci.com/en/posts/12306%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%A5%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C 语言中 void* 详解及应用</h2></header><div class=entry-content><p>C 语言中 void* 详解及应用 void 在英文中作为名词的解释为 “空虚、空间、空隙”，而在 C 语言中，void 被翻译为**“无类型”，相应的void *** 为**“无类型指针”**。
void 似乎只有"注释"和限制程序的作用，当然，这里的"注释"不是为我们人提供注释，而是为编译器提供一种所谓的注释。
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 5 min&nbsp|&nbsp📖字数: 2101 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to C 语言中 void* 详解及应用" href=https://luenci.com/en/posts/c-%E8%AF%AD%E8%A8%80%E4%B8%AD-void-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cookie和Session知识</h2></header><div class=entry-content><p>参考：
https://juejin.im/post/5aa783b76fb9a028d663d70a
https://www.cnblogs.com/wj-1314/p/10496253.html
Session是存储在服务器端的，Cookie是存储在客户端的 Cookie的概念 Cookie是客户端用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在本地机器上存储的一小段文本，并随着每次请求发送到服务器。 Cookie与Session的区别 cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE； 一个服务器最多在客户端浏览器上保存20个Cookie； 一个浏览器最多保存300个Cookie 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K； 上面的数据只是HTTP的Cookie规范，但是在浏览器大战的今天，一些浏览器为了打败对手，为了展示自己的能力起见，可能对Cookie规范“扩展”了一些，例如每个Cookie的大小为8KB，最多可保存500个Cookie等！但也不会出现将你的硬盘占满的可能
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 7 min&nbsp|&nbsp📖字数: 3219 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Cookie和Session知识" href=https://luenci.com/en/posts/django%E7%9A%84cookie%E5%92%8Csession/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C结构体打包技艺</h2></header><div class=entry-content><p>失传的 C 结构体打包技艺（转） 转自： https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=83418&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D571
作者：Eric S. Raymond 原文链接：http://www.catb.org/esr/structure-packing
谁应阅读本文 如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。
2013 年底，我大量应用了一项 C 语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。
通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少 40% 的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。
事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习 —— 如今已不多见。
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 7 min&nbsp|&nbsp📖字数: 3206 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to C结构体打包技艺" href=https://luenci.com/en/posts/c%E8%AF%AD%E8%A8%80%E6%89%93%E5%8C%85%E6%8A%80%E8%89%BA/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>c语言笔记（1）</h2></header><div class=entry-content><p>ps:先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛
C语言中各种数据类型所占用的存储空间的大小 int—32位 四个字节
float —32位 四个字节
char—8位 一个字节
double—-64位 8个字节
bool—-16位 2个字节
long—-32位 四个字节
整数类型 下表列出了关于标准整数类型的存储大小和值范围的细节：
类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 浮点类型 下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：
类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位小数 double 8 字节 2.3E-308 到 1.7E+308 15 位小数 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位小数 void 类型 void 类型指定没有可用的值。它通常用于以下三种情况下：
序号 类型与描述 1 函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 10 min&nbsp|&nbsp📖字数: 5008 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to c语言笔记（1）" href=https://luenci.com/en/posts/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>c语言笔记（2）</h2></header><div class=entry-content><p>先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛
递归 调用函数本身 设置递归结束条件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // // Created by Luenci on 2019/10/11. // #include &lt;stdio.h> void fun(void); long fact(int num); void fun(void){ static int count = 10; printf("Hi\n"); if (count--){ fun(); } } long fact(int num){ long result; if(num > 0){ result = num * fact(num-1); } else{ result = 1; } return result; } int main(void){ // fun(); int num; long re; printf("请输入您要求阶乘的数："); scanf("%d", &amp;num); re = fact(num); printf("%d", re); return 0; } 汉罗塔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include&lt;stdio.h> void hanoi(int n, char x, char y, char z); void hanoi(int n, char x, char y, char z){ if(n==1){ printf("%c --> %c \n", x,z); } else{ // 将前n-1个圆盘借助z移动到y hanoi(n-1, x, z, y); printf("%c --> %c \n", x,z); // 将前n-1个圆盘借助x移动到z hanoi(n-1, y, x, z); } } int main(void){ int n; printf("请输入您的层数："); scanf("%d", &amp;n); hanoi(n, 'X', 'Y', 'Z'); return 0; } 快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // // Created by Luenci on 2019/10/11. // #include &lt;stdio.h> void quick_sort(int array[], int left, int right); void quick_sort(int array[], int left, int right) { int i = left, j = right; int temp; // 交换的中间变量 int pivot; // 基准点 pivot = array[(left + right) / 2]; while (i &lt;= j) { // 从右往左找到大于等于基准点的元素 while (array[i] &lt; pivot) { i++; } // 从右到左找到小于等于基准点的元素 while (array[j] > pivot) { j--; } // 如果 i &lt;= j,则互换 if (i &lt;= j) { temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j++; } } if (left &lt; j) { quick_sort(array, left, j); } if (i &lt; right) { quick_sort(array, i, right); } } int main(void){ int array[] = {73, 108, 111, 101, 78, 109, 66, 48, 88, 135}; int i, length; // 计算数组的长度 length = sizeof(array) / sizeof(array[0]); quick_sort(array, 0, length-1); printf("排序后的结果是："); for (i = 0; i &lt; length; i++){ printf("%d ,", array[i]); } putchar('\n'); return 0; } ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 8 min&nbsp|&nbsp📖字数: 3944 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to c语言笔记（2）" href=https://luenci.com/en/posts/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>c语言笔记（3）</h2></header><div class=entry-content><p>结构体 结构体声明 1 2 3 4 5 6 7 struct Book { 结构体成员1; 结构体成员2; 结构体成员3; ...... }; 定义结构体类型变量
struct 结构体名称 结构体变量名 访问结构体变量
要访问结构体成员，我们需要引入一个新的运算符——点号(.)运算符。比如book.title就是引用book结构体的title成员，它是一个字符数组。 初始结构体的指定成员值
其语法和数组指定初始化元素类似，不过结构体指定初始化成员使用点号（.）运算符和成员名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // // Created by Luenci on 2019/10/13. // #include &lt;stdio.h> struct Book{ char title[128]; char author[40]; float price; unsigned int data; char publisher[40]; }book; int main(void){ // struct Book book1; printf("请输入书名："); scanf("%s", book.title); printf("请输入作者："); scanf("%s", book.author); printf("请输入售价："); scanf("%f", &amp;book.price); printf("请输入出版日期："); scanf("%d", &amp;book.data); printf("请输入出版社："); scanf("%s", book.publisher); printf("\n====数据录入完毕====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d\n", book.data); printf("出版社：%s\n", book.publisher); return 0; } 结构体嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // // Created by Luenci on 2019/10/13. // #include &lt;stdio.h> struct Data{ int year; int month; int day; }; struct Book{ char title[128]; char author[40]; float price; struct Data data; char publisher[40]; }book = { // 初始化 "c学习", "Luenci", 48.8, {2019,11,13}, "文华出版社" }; int main(void){ printf("\n====数据录入为====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d%d%d\n", book.data.year, book.data.month, book.data.day); printf("出版社：%s\n", book.publisher); return 0; } out 书名：c学习 作者：Luenci 售价：48.80 出版日期：20191113 出版社：文华出版社 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 27 min&nbsp|&nbsp📖字数: 13032 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to c语言笔记（3）" href=https://luenci.com/en/posts/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B03/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>django+nginx+uwsgi部署漫谈</h2></header><div class=entry-content><p>写在前面：关于Django的部署问题网上有很多教程，但是每个人的配置环境和遇到的情况都一样，所以在此记录下我部署过程中遇到的问题
**看官方文档：**https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html（特别重要！！！）
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 3 min&nbsp|&nbsp📖字数: 1075 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to django+nginx+uwsgi部署漫谈" href=https://luenci.com/en/posts/django+nginx+uwsgi%E9%83%A8%E7%BD%B2%E6%BC%AB%E8%B0%88/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://luenci.com/en/posts/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://luenci.com/en/posts/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><script src=https://sdk.jinrishici.com/v2/browser/jinrishici.js></script><script type=text/javascript>jinrishici.load(function(e){var t=document.querySelector(".poem_sentence"),n=document.querySelector(".poem_info");t.innerHTML=e.data.content,n.innerHTML="—— "+e.data.origin.author})</script><span><a id=running-time></a><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>👁️‍🗨️访客人数: <span id=busuanzi_value_site_uv></span>|
🌐访问量: <span id=busuanzi_value_site_pv></span></span></span><br><span>&copy; 2026 <a href=https://luenci.com/en/>Luenci</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> 📖
<text class=poem_sentence></text><text class=poem_info></text></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});const RunningTimerInterval=1e3,StartTime=new Date("10/11/2018 00:00:00");function prefixZero(e){return e<10&&(e="0"+e),e}function updateTime(){const r=new Date;let e=r.getTime()-StartTime.getTime();const t=24*60*60*1e3,n=Math.floor(e/t);e-=n*t;const s=60*60*1e3,o=Math.floor(e/s);e-=o*s;const i=60*1e3,a=Math.floor(e/i);e-=a*i;const c=Math.floor(e/1e3),l=document.getElementById("running-time");l.innerText="🕚: "+n+"天"+prefixZero(o)+"小时"+prefixZero(a)+"分"+prefixZero(c)+"秒"}document.addEventListener("DOMContentLoaded",()=>{let e=setInterval(updateTime,RunningTimerInterval)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>