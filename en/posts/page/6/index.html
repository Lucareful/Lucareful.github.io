<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Luenci</title>
<meta name=keywords content><meta name=description content="Posts - Luenci"><meta name=author content="Luenci"><link rel=canonical href=https://luenci.com/en/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luenci.com/images/L.png><link rel=icon type=image/png sizes=16x16 href=https://luenci.com/images/L.png><link rel=icon type=image/png sizes=32x32 href=https://luenci.com/images/L.png><link rel=apple-touch-icon href=https://luenci.com/L.png><link rel=mask-icon href=https://luenci.com/L.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://luenci.com/en/posts/index.xml><link rel=alternate hreflang=en href=https://luenci.com/en/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://umami.luenci.com/script.js data-website-id=b0a9e971-b470-43a2-bda9-182c654377f4></script><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://luenci.com/en/posts/"><meta property="og:site_name" content="(〃'▽'〃)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luenci.com/en/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luenci.com/en/ accesskey=h title="Luenci (Alt + H)"><img src=https://luenci.com/images/avatar.jpg alt aria-label=logo height=35>Luenci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luenci.com/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://luenci.com/en/posts title=📚文章><span class=active>📚文章</span></a></li><li><a href=https://luenci.com/en/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luenci.com/en/archives title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luenci.com/en/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luenci.com/en/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luenci.com/en/links title=🤝友链><span>🤝友链</span></a></li><li><a href=https://luenci.com/en/index.xml title=📬RSS><span>📬RSS</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://luenci.com/en/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet。
一、QuerySet何时被提交 在内部，创建、过滤、切片和传递一个QuerySet不会真实操作数据库，在你对查询集提交之前，不会发生任何实际的数据库操作。可以使用下列方法对QuerySet提交查询操作： 迭代 QuerySet是可迭代的，在首次迭代查询集时执行实际的数据库查询。 例如， 下面的语句会将数据库中所有Entry的headline打印出来： 1 2 for e in Entry.objects.all(): print(e.headline) 切片：如果使用切片的”step“参数，Django 将执行数据库查询并返回一个列表。 Pickling/缓存 repr()
...</p></div><footer class=entry-footer>26 min&nbsp;·&nbsp;12928 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to " href=https://luenci.com/en/posts/django%E7%9A%84queryset%E8%AF%A6%E8%A7%A3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Golang 的值传递 先导文章：（正经版）面试官：切片作为函数参数是传值还是传引用？
Go语言中的 new 和 make 主要区别如下：
make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据； new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type； new 分配的空间被清零。make 分配空间后，会进行初始化； 传入参数和传出参数 传入参数为本身有值，传入函数让函数使用；传出参数本身没值，从函数中带出值（相当于函数的返回值）。 函数参数为指针 将指针作为参数传入某个函数时，函数内部会复制指针，也就是会同时出现两个指针指向原有的内存空间，所以 Go 语言中传指针也是传值。
传值 当我们验证了 Go 语言中大多数常见的数据结构之后，其实能够推测出 Go 语言在传递参数时使用了传值的方式，接收方收到参数时会对这些参数进行复制；了解到这一点之后，在传递数组或者内存占用非常大的结构体时，我们应该尽量使用指针作为参数类型来避免发生数据拷贝进而影响性能。
函数小结 通过堆栈传递参数，入栈的顺序是从右到左，而参数的计算是从左到右； 函数返回值通过堆栈传递并由调用者预先分配内存空间； 调用函数时都是传值，接收方会对入参进行复制再计算； ...</p></div><footer class=entry-footer>3 min&nbsp;·&nbsp;1135 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to " href=https://luenci.com/en/posts/golang%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>12306自动化抢票实现</h2></header><div class=entry-content><p>selenium常用API find_element_by_xxx 返回第一个符合条件WebElement元素 find_elements_by_xxx 返回符合条件所有元素包含了 WebEelemnt 列表 函数 作用 find_element_by_class_name 通过class查询元素 find_element_by_id 通过ID查询元素 find_element_by_name 通过name查询元素 find_element_by_tag_name 通过标签名称 find_element_by_css_selector css样式选择 find_element_by_link_text 通过链接内容查找 find_element_by_partial_link_text 通过链接内容包含的内容查找，模糊查询 find_element_by_xpath 通过xpath查找数据 获取元素属性和文本内容 1 2 3 4 5 6 7 8 #获取属性 element.get_attribute（'属性名”） #获取文本内容 element.text # 输入框输入内容 input_element.send_keys（'Luenci'） # 元素点击 element.click() 三种等待方式 当控制浏览器时，浏览器正在加载页面同时又去获取数据导致浏览器寻找不到需要操作的元素引发异常。 方式一：强制等待，浪费时间 time.sleep（秒数） 方式二：隐性等待，无法控制Ajax请求 browser.implicit1y_wait（等待时间） 方式三：显性等待，每个元素都可以自己定义检查条件。手动编写方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #显性等待-手动编写 t = time.time（） #定义超时时间 timeout = 60 while True： try： #超时时间间隔 time.sleep（0.1） ur1_element = browser.find_element_by_class_name（"fav ur1"） break except： #超时处理 if time.time（）- t > timeout： break pass 系统提供显性等待API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 导入显性等待的API需要的模块 # 1等待对象模块 from selenium.webdriver.support.wait import WebDriverwait # 2导入等待条件模块 from selenium.webdriver.support import expected_conditions as EC # 3导入查询元素模块 from selenium.webdriver.common.by import By # 1.创建等待对象 # 参数一浏览器对象 # 参数二超时时间 # 参数三检查元素时间间隔 wait = WebDriverwait（browser，5.0，0.5） # 2.通过等待对象获取元素 # presence_of_element_located 检查元素是否存在，如果存在就返回如果不存在就继续检查 # visibility_of_element_located 检查元素是否可见 linkelement = s wait.until（EC.presence_of_element_located（（By.CLASS_NAME，"favurl"） link_element.click（） 12306爬虫实现 完成代码见：https://github.com/Lucareful/12306_Tickets
实现步骤 1.访问列表页 2.通过时间判定选择点击预订 3.点击账号登录 4.输入用户名和密码（15523750230） 5.截图获取验证码图片 6.发送打码平台获取识别数字 7.定义8个点击坐标 8.模拟点击坐标 9.点击登录 10.点击选择人物 11.点击提交订单 12.点击确认订单 ...</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1773 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 12306自动化抢票实现" href=https://luenci.com/en/posts/12306%E8%87%AA%E5%8A%A8%E6%8A%A2%E7%A5%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C 语言中 void* 详解及应用</h2></header><div class=entry-content><p>C 语言中 void* 详解及应用 void 在英文中作为名词的解释为 “空虚、空间、空隙”，而在 C 语言中，void 被翻译为**“无类型”，相应的void *** 为**“无类型指针”**。
void 似乎只有"注释"和限制程序的作用，当然，这里的"注释"不是为我们人提供注释，而是为编译器提供一种所谓的注释。
...</p></div><footer class=entry-footer>5 min&nbsp;·&nbsp;2101 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to C 语言中 void* 详解及应用" href=https://luenci.com/en/posts/c-%E8%AF%AD%E8%A8%80%E4%B8%AD-void-%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cookie和Session知识</h2></header><div class=entry-content><p>参考：
https://juejin.im/post/5aa783b76fb9a028d663d70a
https://www.cnblogs.com/wj-1314/p/10496253.html
Session是存储在服务器端的，Cookie是存储在客户端的 Cookie的概念 Cookie是客户端用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在本地机器上存储的一小段文本，并随着每次请求发送到服务器。 Cookie与Session的区别 cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE； 一个服务器最多在客户端浏览器上保存20个Cookie； 一个浏览器最多保存300个Cookie 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K； 上面的数据只是HTTP的Cookie规范，但是在浏览器大战的今天，一些浏览器为了打败对手，为了展示自己的能力起见，可能对Cookie规范“扩展”了一些，例如每个Cookie的大小为8KB，最多可保存500个Cookie等！但也不会出现将你的硬盘占满的可能
...</p></div><footer class=entry-footer>7 min&nbsp;·&nbsp;3219 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Cookie和Session知识" href=https://luenci.com/en/posts/django%E7%9A%84cookie%E5%92%8Csession/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C结构体打包技艺</h2></header><div class=entry-content><p>失传的 C 结构体打包技艺（转） 转自： https://fishc.com.cn/forum.php?mod=viewthread&amp;tid=83418&amp;extra=page%3D2%26filter%3Dtypeid%26typeid%3D571
作者：Eric S. Raymond 原文链接：http://www.catb.org/esr/structure-packing
谁应阅读本文 如果你在内存容量受限的嵌入式系统中写程序，或者编写操作系统内核代码，就有必要了解这项技术。如果数据集巨大，应用时常逼近内存极限，这项技术会有所帮助。倘若你非常非常关心如何最大限度地减少处理器缓存段（cache-line）未命中情况的发生，这项技术也有所裨益。
2013 年底，我大量应用了一项 C 语言优化技术，这项技术是我早在二十余年前就已掌握的，但彼时之后，鲜有使用。
通过精心调整结构成体员的顺序，可以在这种情况下大幅减少内存占用。其效果显著——在上述案例中，可以减少 40% 的内存空间。程序应用于更大的软件仓库，也不会因内存耗尽而崩溃。
事出有因。计算机科学课程（正确地）引导人们远离微观优化，转而寻求更理想的算法。计算成本一路走低，令压榨内存的必要性变得越来越低。旧日里，黑客们通过在陌生的硬件架构中跌跌撞撞学习 —— 如今已不多见。
...</p></div><footer class=entry-footer>7 min&nbsp;·&nbsp;3206 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to C结构体打包技艺" href=https://luenci.com/en/posts/c%E8%AF%AD%E8%A8%80%E6%89%93%E5%8C%85%E6%8A%80%E8%89%BA/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>c语言笔记（1）</h2></header><div class=entry-content><p>ps:先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛
C语言中各种数据类型所占用的存储空间的大小 int—32位 四个字节
float —32位 四个字节
char—8位 一个字节
double—-64位 8个字节
bool—-16位 2个字节
long—-32位 四个字节
整数类型 下表列出了关于标准整数类型的存储大小和值范围的细节：
类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 浮点类型 下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：
类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位小数 double 8 字节 2.3E-308 到 1.7E+308 15 位小数 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位小数 void 类型 void 类型指定没有可用的值。它通常用于以下三种情况下：
序号 类型与描述 1 函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。 ...</p></div><footer class=entry-footer>10 min&nbsp;·&nbsp;5008 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to c语言笔记（1）" href=https://luenci.com/en/posts/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B01/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>c语言笔记（2）</h2></header><div class=entry-content><p>先举三反一，再举一反三，学习就应该是这样，先模仿，再改进，最后实现自己的创意！ –小甲鱼论坛
递归 调用函数本身 设置递归结束条件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // // Created by Luenci on 2019/10/11. // #include &lt;stdio.h> void fun(void); long fact(int num); void fun(void){ static int count = 10; printf("Hi\n"); if (count--){ fun(); } } long fact(int num){ long result; if(num > 0){ result = num * fact(num-1); } else{ result = 1; } return result; } int main(void){ // fun(); int num; long re; printf("请输入您要求阶乘的数："); scanf("%d", &amp;num); re = fact(num); printf("%d", re); return 0; } 汉罗塔 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include&lt;stdio.h> void hanoi(int n, char x, char y, char z); void hanoi(int n, char x, char y, char z){ if(n==1){ printf("%c --> %c \n", x,z); } else{ // 将前n-1个圆盘借助z移动到y hanoi(n-1, x, z, y); printf("%c --> %c \n", x,z); // 将前n-1个圆盘借助x移动到z hanoi(n-1, y, x, z); } } int main(void){ int n; printf("请输入您的层数："); scanf("%d", &amp;n); hanoi(n, 'X', 'Y', 'Z'); return 0; } 快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // // Created by Luenci on 2019/10/11. // #include &lt;stdio.h> void quick_sort(int array[], int left, int right); void quick_sort(int array[], int left, int right) { int i = left, j = right; int temp; // 交换的中间变量 int pivot; // 基准点 pivot = array[(left + right) / 2]; while (i &lt;= j) { // 从右往左找到大于等于基准点的元素 while (array[i] &lt; pivot) { i++; } // 从右到左找到小于等于基准点的元素 while (array[j] > pivot) { j--; } // 如果 i &lt;= j,则互换 if (i &lt;= j) { temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j++; } } if (left &lt; j) { quick_sort(array, left, j); } if (i &lt; right) { quick_sort(array, i, right); } } int main(void){ int array[] = {73, 108, 111, 101, 78, 109, 66, 48, 88, 135}; int i, length; // 计算数组的长度 length = sizeof(array) / sizeof(array[0]); quick_sort(array, 0, length-1); printf("排序后的结果是："); for (i = 0; i &lt; length; i++){ printf("%d ,", array[i]); } putchar('\n'); return 0; } ...</p></div><footer class=entry-footer>8 min&nbsp;·&nbsp;3944 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to c语言笔记（2）" href=https://luenci.com/en/posts/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>c语言笔记（3）</h2></header><div class=entry-content><p>结构体 结构体声明 1 2 3 4 5 6 7 struct Book { 结构体成员1; 结构体成员2; 结构体成员3; ...... }; 定义结构体类型变量
struct 结构体名称 结构体变量名 访问结构体变量
要访问结构体成员，我们需要引入一个新的运算符——点号(.)运算符。比如book.title就是引用book结构体的title成员，它是一个字符数组。 初始结构体的指定成员值
其语法和数组指定初始化元素类似，不过结构体指定初始化成员使用点号（.）运算符和成员名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // // Created by Luenci on 2019/10/13. // #include &lt;stdio.h> struct Book{ char title[128]; char author[40]; float price; unsigned int data; char publisher[40]; }book; int main(void){ // struct Book book1; printf("请输入书名："); scanf("%s", book.title); printf("请输入作者："); scanf("%s", book.author); printf("请输入售价："); scanf("%f", &amp;book.price); printf("请输入出版日期："); scanf("%d", &amp;book.data); printf("请输入出版社："); scanf("%s", book.publisher); printf("\n====数据录入完毕====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d\n", book.data); printf("出版社：%s\n", book.publisher); return 0; } 结构体嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // // Created by Luenci on 2019/10/13. // #include &lt;stdio.h> struct Data{ int year; int month; int day; }; struct Book{ char title[128]; char author[40]; float price; struct Data data; char publisher[40]; }book = { // 初始化 "c学习", "Luenci", 48.8, {2019,11,13}, "文华出版社" }; int main(void){ printf("\n====数据录入为====\n\n"); printf("书名：%s\n", book.title); printf("作者：%s\n", book.author); printf("售价：%.2f\n", book.price); printf("出版日期：%d%d%d\n", book.data.year, book.data.month, book.data.day); printf("出版社：%s\n", book.publisher); return 0; } out 书名：c学习 作者：Luenci 售价：48.80 出版日期：20191113 出版社：文华出版社 ...</p></div><footer class=entry-footer>27 min&nbsp;·&nbsp;13032 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to c语言笔记（3）" href=https://luenci.com/en/posts/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B03/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>django+nginx+uwsgi部署漫谈</h2></header><div class=entry-content><p>写在前面：关于Django的部署问题网上有很多教程，但是每个人的配置环境和遇到的情况都一样，所以在此记录下我部署过程中遇到的问题
**看官方文档：**https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html（特别重要！！！）
...</p></div><footer class=entry-footer>3 min&nbsp;·&nbsp;1075 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to django+nginx+uwsgi部署漫谈" href=https://luenci.com/en/posts/django+nginx+uwsgi%E9%83%A8%E7%BD%B2%E6%BC%AB%E8%B0%88/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django之编写URL</h2></header><div class=entry-content><p>编写URL 编写规则 ​ 为了使其规范性，在每个新创建的App中设置独立的静态资源和模板文件夹并添加一个空白的.py文件，命为urls.py。如下是创建app中的文件结构：
...</p></div><footer class=entry-footer>3 min&nbsp;·&nbsp;1189 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Django之编写URL" href=https://luenci.com/en/posts/django%E4%B9%8Burl%E8%A7%84%E5%88%99/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django参数和模板</h2></header><div class=entry-content><p>render方法参数 request: 是一个固定参数。 template_name: templates 中定义的文件, 要注意路径名. 比如’templates\polls\index.html’, 参数就要写‘polls\index.html’ context: 要传入文件中用于渲染呈现的数据, 默认是字典格式 content_type: 生成的文档要使用的MIME 类型。默认为DEFAULT_CONTENT_TYPE 设置的值。 status: http的响应代码,默认是200. using: 用于加载模板使用的模板引擎的名称。 request对象方法和属性 request.scheme # 代表请求的方案,http或者https request.body# 原始HTTP请求主体为字节串。这对于以不同于常规HTML格式的方式处理数据很有用：二进制图像，XML有效负载等。对于处理常规格式的数据，请使用 HttpRequest.POST。 request.path # 请求的路径,比如请求127.0.0.1/org/list,那这个值就是/org/list request.get_full_path() # 获取完整的请求路径 request.method # 表示请求使用的http方法,GET或者POST请求 request.encoding # 表示提交数据的编码方式 request.GET # 获取GET请求 request.POST # 获取post的请求,比如前端提交的用户密码,可以通过request.POST.get()来获取 NOTICED：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中
...</p></div><footer class=entry-footer>6 min&nbsp;·&nbsp;2969 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Django参数和模板" href=https://luenci.com/en/posts/django%E5%8F%82%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django的ORM多表操作</h2></header><div class=entry-content><p>ORM多表操作 API 函数 说明 all() 查询所有结果 filter(**kwargs) 包含了与所给筛选条件相匹配的对象 get(**kwargs) 返回与所给筛选条件相匹配的对象，返回结果有且只有一个， 如果符合筛选条件的对象超过一个或者没有都会抛出错误。 exclude(**kwargs) 它包含了与所给筛选条件不匹配的对象 order_by(*field) 对查询结果排序 用法:order_by (“price”) DESC 降序 reverse(): 对查询结果反向排序 count() 返回数据库中匹配查询(QuerySet)的对象数量 first() 返回第一条记录 last() 返回最后一条记录 exists() 如果QuerySet包含数据，就返回True，否则返回False 相当于limit 1(用途查询这个表中是否有值) values(*field) 用法:Book.objects.all.values(‘title’,‘price’) 返回值是&lt;queryset[{‘title’:‘aa’,‘pirce’:12},{}] values_list(*field): 用法:Book.objects.all.values_list(‘title’,‘price’) 返回值是&lt;queryset[(‘aa’,12),(‘bb’,33)] distinct() 从返回结果中剔除重复纪录 用法:Book.objects.all.values(‘title’,‘price’).distinct() 错误用法 Book.objects.all.distinct() 因为id不相同,其他相同,无法去重 模糊查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 __exact 精确等于 like ‘aaa’ __iexact 精确等于 忽略大小写 ilike ‘aaa’ __contains 是否包含 like ‘%aaa%’ __icontains 包含 忽略大小写 ilike ‘%aaa%’，但是对于sqlite来说，contains的作用效果等同于icontains。 __gt 大于 __gte 大于等于 __lt 小于 __lte 小于等于 __in 存在于一个list范围内 __startswith 以…开头 __istartswith 以…开头 忽略大小写 __endswith 以…结尾 __iendswith 以…结尾，忽略大小写 __range 在…范围内 __year 日期字段的年份 __month 日期字段的月份 __day 日期字段的日 __isnull=True/False __isnull=True 与 __exact=None的区别 外键的定义 1 2 3 4 5 6 7 8 9 10 11 # modeld.py class Book(models.Model): name = models.CharField(max_length=20) price = models.FloatField() pub_date = models.DateField() publish = models.ForeignKey("Publish",on_delete=models.CASCADE) class Publish(models.Model): name = models.CharField(max_length=32) city = models.CharField(max_length=32) on_delete的参数 CASCADE:这就是默认的选项，级联删除，你无需显性指定它。 PROTECT: 保护模式，如果采用该选项，删除的时候，会抛出ProtectedError错误。 SET_NULL: 置空模式，删除的时候，外键字段被设置为空，前提就是blank=True, null=True,定义该字段的时候，允许为空。 SET_DEFAULT: 置默认值，删除的时候，外键字段设置为默认值，所以定义外键的时候注意加上一个默认值。 SET(): 自定义一个值，该值只能是对应的实体了 DO_NOTHING:不采取行动。如果您的数据库后端强制执行参照完整性，会造成IntegrityError，除非您手动将SQL 约束ON DELETE添加到数据库字段。 一对多之对象查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 通过外键实现关联查询 # 一对多： book_obj ————————————》一定是一个对象 book_obj = Book.objects.get(name="python进阶") print(book_obj.publish) print(book_obj.publish.name) print(book_obj.publish.city) # 查询出版社出版的所有书籍和价格 # 方法一 pub_obj = Publish.objects.filter(name="人民出版社")[0] ret = Book.objects.filter(publish=pub_obj).values("name","price") print(ret) # &lt;QuerySet [{'name': 'linux运维', 'price': 77.0}]> # 方法二 pub_obj = Publish.objects.filter(name="机械出版社")[0] print(pub_obj.book_set.all()) # &lt;QuerySet [&lt;Book: python进阶>]> print(type(pub_obj.book_set.all())) # &lt;class 'django.db.models.query.QuerySet'> print(pub_obj.book_set.all().values("name", "price")) 多对多对象添加 1 2 3 4 5 6 7 # 多对多添加信息 book_obj = Book.objects.get(id=2) author_obj = Author.objects.get(id=1) # 添加关系 book_obj.author.add(author_obj) # 删除关系 book_obj.author.remove(author_obj) 聚合查询与分组查询 聚合查询: aggregate(*args, **kwargs) 1 2 3 4 5 6 #1.聚合 aggregate:返回值是一个字典 from django.db.models import Avg,Max,Min,Count #问题:查询所有书籍的平均价格,最高价格,最低价格 ret = Book.objects.all().aggregate(avg_price=Avg('price'),max_price = Max('price'),min_price=Min('price')) print(ret) aggregate()是QuerySet 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。如果你想要为聚合值指定一个名称，可以向聚合子句提供它。 分组查询 annotate(*args, **kwargs) 表单模型.objects.values(“group by 分组字段”).annotate(聚合函数(‘聚合字段’)) F查询 Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。 Q查询 filter() 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如OR语句），你可以使用Q对象</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1769 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Django的ORM多表操作" href=https://luenci.com/en/posts/django%E7%9A%84orm%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django的ORM字段介绍</h2></header><div class=entry-content><p>Django的Field详解（转载） 本文转载于：https://www.cnblogs.com/ellisonzhang/p/10679054.html
字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 1、models.AutoField　自增列 = int(11) 如果没有的话，默认会生成一个名称为 id 的列，如果要显示的自定义一个自增列，必须将给列设置为主键 primary_key=True。 2、models.CharField　字符串字段 必须 max_length 参数 3、models.BooleanField　布尔类型=tinyint(1) 不能为空，Blank=True 4、models.ComaSeparatedIntegerField　用逗号分割的数字=varchar 继承CharField，所以必须 max_lenght 参数 5、models.DateField　日期类型 date 对于参数，auto_now = True 则每次更新都会更新这个时间；auto_now_add 则只是第一次创建添加，之后的更新不再改变。 6、models.DateTimeField　日期类型 datetime 同DateField的参数 7、models.Decimal　十进制小数类型 = decimal 必须指定整数位max_digits和小数位decimal_places 8、models.EmailField　字符串类型（正则表达式邮箱） =varchar 对字符串进行正则表达式 9、models.FloatField　浮点类型 = double 10、models.IntegerField　整形 11、models.BigIntegerField　长整形 integer_field_ranges = { 'SmallIntegerField': (-32768, 32767), 'IntegerField': (-2147483648, 2147483647), 'BigIntegerField': (-9223372036854775808, 9223372036854775807), 'PositiveSmallIntegerField': (0, 32767), 'PositiveIntegerField': (0, 2147483647), } 12、models.IPAddressField　字符串类型（ip4正则表达式） 13、models.GenericIPAddressField　字符串类型（ip4和ip6是可选的） 参数protocol可以是：both、ipv4、ipv6 验证时，会根据设置报错 14、models.NullBooleanField　允许为空的布尔类型 15、models.PositiveIntegerFiel　正Integer 16、models.PositiveSmallIntegerField　正smallInteger 17、models.SlugField　减号、下划线、字母、数字 18、models.SmallIntegerField　数字 数据库中的字段有：tinyint、smallint、int、bigint 19、models.TextField　字符串=longtext 20、models.TimeField　时间 HH:MM[:ss[.uuuuuu]] 21、models.URLField　字符串，地址正则表达式 22、models.BinaryField　二进制 23、models.ImageField 图片 24、models.FilePathField 文件 参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 1、null=True 数据库中字段是否可以为空 2、blank=True django的 Admin 中添加数据时是否可允许空值 3、primary_key = False 主键，对AutoField设置主键后，就会代替原来的自增 id 列 4、auto_now 和 auto_now_add auto_now 自动创建---无论添加或修改，都是当前操作的时间 auto_now_add 自动创建---永远是创建时的时间 5、choices sex_choice=((“F”,“FEMAL”),(“M”,’Male’),)　#admin专用下拉选项 gender=models.CharFiled(max_length=2,choice=sex_choice) 6、max_length 7、default　默认值 8、verbose_name　Admin中字段的显示名称 9、name|db_column　数据库中的字段名称 10、unique=True　不允许重复 11、db_index = True　数据库索引 12、editable=True　在Admin里是否可编辑 13、error_messages=None　错误提示 14、auto_created=False　自动创建 15、help_text　在Admin中提示帮助信息 16、validators=[] 17、upload-to</p></div><footer class=entry-footer>4 min&nbsp;·&nbsp;1664 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Django的ORM字段介绍" href=https://luenci.com/en/posts/django%E7%9A%84field%E8%AF%A6%E8%A7%A3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django简介</h2></header><div class=entry-content><p>Django简介 背景 2003诞生 它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的 MVT（框架） Models 模型 数据库
Views 视图 放和拿
Template 模板 前端
From 表单 django 会根据你后台数据库字段及表单层的设计对应的给你创建HTML关于表单的代码 Django优点 对象关系映射（Object Relational Mapping ORM）：通过定义映射类来构建数据模型，将模型与关系型数据库连接起来，使用ORM框架内置的数据库接口可实现复杂的数据操作。（简单来说就是把数据库的语句换成了python可识别的语言） URL设计：开发者可以设计任意的URL（网站地址）， 而且支持使用正则表达式设计。 模板系统：提供可扩展的模板语言，模板之间具有可继承性。 表单处理：可以生成各种表单模型，而且表单具有有效性检验功能。 Cache系统：完善的缓存系统，可支持多种缓存方式 用户管理系统：提供用户认证，权限设置和用户组功能，功能扩展性强。 国际化：内置国际化系统，方便开发出多语言的网站。 admin管理系统：内置admin管理系统，系统的扩展性强。 ...</p></div><footer class=entry-footer>11 min&nbsp;·&nbsp;5155 words&nbsp;·&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Django简介" href=https://luenci.com/en/posts/django%E9%85%8D%E7%BD%AE%E5%88%9D%E5%90%AF/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://luenci.com/en/posts/page/5/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://luenci.com/en/posts/page/7/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><script src=https://sdk.jinrishici.com/v2/browser/jinrishici.js></script><script type=text/javascript>jinrishici.load(function(e){var t=document.querySelector(".poem_sentence"),n=document.querySelector(".poem_info");t.innerHTML=e.data.content,n.innerHTML="—— "+e.data.origin.author})</script><span><a id=running-time></a><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>👁️‍🗨️访客人数: <span id=busuanzi_value_site_uv></span>|
🌐访问量: <span id=busuanzi_value_site_pv></span></span></span><br><span>&copy; 2025 <a href=https://luenci.com/en/>Luenci</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> 📖
<text class=poem_sentence></text><text class=poem_info></text></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});const RunningTimerInterval=1e3,StartTime=new Date("10/11/2018 00:00:00");function prefixZero(e){return e<10&&(e="0"+e),e}function updateTime(){const r=new Date;let e=r.getTime()-StartTime.getTime();const t=24*60*60*1e3,n=Math.floor(e/t);e-=n*t;const s=60*60*1e3,o=Math.floor(e/s);e-=o*s;const i=60*1e3,a=Math.floor(e/i);e-=a*i;const c=Math.floor(e/1e3),l=document.getElementById("running-time");l.innerText="🕚: "+n+"天"+prefixZero(o)+"小时"+prefixZero(a)+"分"+prefixZero(c)+"秒"}document.addEventListener("DOMContentLoaded",()=>{let e=setInterval(updateTime,RunningTimerInterval)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>