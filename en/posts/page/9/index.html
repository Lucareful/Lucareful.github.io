<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Luenci</title>
<meta name=keywords content><meta name=description content="Posts - Luenci"><meta name=author content="Luenci"><link rel=canonical href=https://luenci.com/en/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://luenci.com/images/L.png><link rel=icon type=image/png sizes=16x16 href=https://luenci.com/images/L.png><link rel=icon type=image/png sizes=32x32 href=https://luenci.com/images/L.png><link rel=apple-touch-icon href=https://luenci.com/L.png><link rel=mask-icon href=https://luenci.com/L.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://luenci.com/en/posts/index.xml><link rel=alternate hreflang=en href=https://luenci.com/en/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://umami.luenci.com/script.js data-website-id=b0a9e971-b470-43a2-bda9-182c654377f4></script><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://luenci.com/en/posts/"><meta property="og:site_name" content="(〃'▽'〃)"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://luenci.com/en/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://luenci.com/en/ accesskey=h title="Luenci (Alt + H)"><img src=https://luenci.com/images/avatar.jpg alt aria-label=logo height=35>Luenci</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://luenci.com/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://luenci.com/en/posts title=📚文章><span class=active>📚文章</span></a></li><li><a href=https://luenci.com/en/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://luenci.com/en/archives title=⏱时间轴><span>⏱时间轴</span></a></li><li><a href=https://luenci.com/en/tags title=🔖标签><span>🔖标签</span></a></li><li><a href=https://luenci.com/en/about title=🙋🏻‍♂️关于><span>🙋🏻‍♂️关于</span></a></li><li><a href=https://luenci.com/en/links title=🤝友链><span>🤝友链</span></a></li><li><a href=https://luenci.com/en/index.xml title=📬RSS><span>📬RSS</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://luenci.com/en/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>python的进程，线程和协程对比</h2></header><div class=entry-content><p>概念 进程 ​ 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
线程 ​ 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
协程 ​ 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。
三者关系 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 2 min&nbsp|&nbsp📖字数: 733 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python的进程，线程和协程对比" href=https://luenci.com/en/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%AF%B9%E6%AF%94/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>python的进程概念</h2></header><div class=entry-content><p>进程 进程概念 进程（Process）是资源分配的最小单位，是线程的容器。
程序是固定不变的，而进程会根据运行需要，让操作系统动态分配各种资源的CPU的时间片轮转，在不同的时间段切换执行不同的进程，但是切换进程是比较耗时的；就引来了轻量级进程，也就是所谓的线程，一个进程中包括多个线程（代码流，其实也就是进程中同时跑的多个方法体）
程序：例xxx.py这是程序，是一个静态的
进程：一个程序运行起来后，代码+用到的资源称之为进程，它是操作系统分配资源的基本单元。
进程状态 工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态
进程状态
就绪态：运行的条件都已经满足，正在等在cpu执行 执行态：cpu正在执行其功能 等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态 进程的创建 - multiprocessing multiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。
·创建子进程跟创建线程十分类似，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start0方法后动
Process语法结构如下： Process([group [，target[，name，[args[，kwargs]]]）
target：如果传递了函数的引用，这个子进程就执行这里（函数）的代码 args：给target指定的函数传递的参数，以元组的方式传递 kwargs：给target指定的函数传递命名参数 name：给进程设定一个名字，可以不设定 group：指定进程组，大多数情况下用不到 Process创建的实例对象的常用方法：
start()：后动子进程实例（创建子进程） is_alive：判断进程子进程是否还在活着 join([timeout]）：是否等待子进程执行结束，或等待多少秒o terminate：不管任务是否完成，立即终止子进程 Process创建的实例对象的常用属性：
name：当前进程的别名，默认为Process-N，N为从1开始递增的整数 pid：当前进程的pid（进程号） linux系统可使用kill命令结束进程
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 9 min&nbsp|&nbsp📖字数: 4160 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python的进程概念" href=https://luenci.com/en/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>python的闭包和装饰器</h2></header><div class=entry-content><p>闭包 引入 函数名是一个特殊的变量，保存了函教的地址和 自定义一个变量可以获取函数地址 自定义变量调用函数 “函数名（）” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def work(): print("我是一个测试函数") ret = work print(ret) print("地址：%X" % id(ret)) print("地址：%X" % id(work)) ret() work() out: &lt;function work at 0x00000161E3091E18> 地址：161E3091E18 地址：161E3091E18 我是一个测试函数 我是一个测试函数 当我们定义函数test1后，函数名test1保存的是函数在内存的首地址函数名就是一个特殊的变量，函数名（）调用函数，执行函数体test1()和ret()都会调用函数，并执行函数体 和变量名一样的，函数名数名只是函数代码空间的引用，当函数名赋值给一个对象的时候就是引用传递。 闭包概念 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 5 min&nbsp|&nbsp📖字数: 2165 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python的闭包和装饰器" href=https://luenci.com/en/posts/%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python类中的 私有变量 和 私有方法</h2></header><div class=entry-content><p>Python中的类 原文转自：https://blog.csdn.net/sxingming/article/details/52875125
默认情况下，Python中的成员函数和成员变量都是公开的(public),在python中没有类似public,private等关键词来修饰成员函数和成员变量。
在python中定义私有变量只需要在变量名或函数名前加上 __两个下划线，那么这个函数或变量就是私有的了。
在内部，python使用一种 name mangling 技术，将 __membername替换成 _classname__membername，也就是说，类的内部定义中,所有以双下划线开始的名字都被"翻译"成前面加上单下划线和类名的形式。
例如：为了保证不能在class之外访问私有变量，Python会在类的内部自动的把我们定义的__spam私有变量的名字替换成为 _classname__spam(注意，classname前面是一个下划线，spam前是两个下划线)，因此，用户在外部访问__spam的时候就会提示找不到相应的变量。
python中的私有变量和私有方法仍然是可以访问的
访问方法如下： 私有变量:实例._类名__变量名 私有方法:实例._类名__方法名()
其实，Python并没有真正的私有化支持，但可用下划线得到伪私有。 尽量避免定义以下划线开头的变量！
（1）_xxx “单下划线 " 开始的成员变量叫做保护变量，意思是只有类实例和子类实例能访问到这些变量， 需通过类提供的接口进行访问；不能用’from module import *‘导入 （2）__xxx 类中的私有变量/方法名 （Python的函数也是对象，所以成员方法称为成员变量也行得通。）, " 双下划线 " 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。 （3）__xxx__ 系统定义名字，前后均有一个“双下划线” 代表python里特殊方法专用的标识，如 __init__（）代表类的构造函数。 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 4 min&nbsp|&nbsp📖字数: 1561 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Python类中的 私有变量 和 私有方法" href=https://luenci.com/en/posts/python%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python类补充</h2></header><div class=entry-content><p>item系列 __getitem__ 以字典形式访问属性的时候触发 __setitem__ 以字典形式设置属性的时候触发 __delitem__ 以字典形式删除属性的时候触发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Demo(object): def __getitem__(self, item): print("触发__getitem__") def __setitem__(self, key, value): print("触发__setitem__") self.__dict__[key] = value def __delitem__(self, key): print("触发__delitem__") self.__dict__.pop(key) f = Demo() # 以字典的方式来操作属性 print(f.__dict__) f['name'] = 'luenci' print(f.__dict__) print(f['name']) del f['name'] print(f.__dict__) out: {} 触发__setitem__ {'name': 'luenci'} 触发__getitem__ None 触发__delitem__ {} __str__和__repr__控制输出 __str__会在print()打印时候调用，如果类中没重写则会调用默认的打印值，如果自定义了则会调用自定义的__str__方法 __repr__这个实在控制台的时候输出，若一个类中没定义__str__但是定义了__repr__方法，则会调用__repr__的返回值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class bar(object): def __init__(self, name, age): self.name = name self.age = age # def __str__(self): # return '__str__自定义返回值' def __repr__(self): return '__repr__自定义返回值' f = bar('luenci', 18) # print() 函数触发__str__()函数 print(f) out: __repr__自定义返回值 __slots__属性 1.__slots__是什么？
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 5 min&nbsp|&nbsp📖字数: 2176 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Python类补充" href=https://luenci.com/en/posts/python%E7%B1%BB%E8%A1%A5%E5%85%85/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>python解释器介绍</h2></header><div class=entry-content><p>CPython 当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 2 min&nbsp|&nbsp📖字数: 652 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python解释器介绍" href=https://luenci.com/en/posts/python%E8%A7%A3%E9%87%8A%E5%99%A8%E4%BB%8B%E7%BB%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>python解释器的GIL锁</h2></header><div class=entry-content><p>GlL锁定义 Gll锁：Global Interpreter Lock，又称：全局解释器锁
任何Python线程执行前，必须先获得GlL锁，然后，每执行100条字节码，解释器就自动释放GL锁，让别的线程有机会执行。这个GlL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 5 min&nbsp|&nbsp📖字数: 2107 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to python解释器的GIL锁" href=https://luenci.com/en/posts/gil%E9%94%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python面向对象</h2></header><div class=entry-content><p>类的定义 把一类事物的相同的特征和动作整合到一起就是类，类是一个抽象的概念 对象的定义 基于类而创建一个具体的事物，类的实例化 接口继承 继承的第二种含义非常重要。它又叫“接口继承”。 接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。 归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象linux的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，对底层设计者，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 导入抽象基类模块 import abc # 定义接口（基类） class File(metaclass=abc.ABCMeta): @abc.abstractmethod def read(self): pass @abc.abstractmethod def write(self): pass class disk(File): def read(self): print("disk read") def write(self): print("disk wirte") ds = disk() ds.read() 子类中调用父类的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Grandfather(object): def __init__(self, name, age): self.age = age self.name = name def grandfather(self): print("grandfather method") class Father(Grandfather): def __init__(self, name, age): super().__init__(name,age) def father_method(self): print("father method") class Son(Father): def __init__(self, name, age,sex): # 调用父类的构造方法 super().__init__(name,age) self.sex = sex # 子类中调用父类方法 def son_method(self): Father.father_method(self) def son_method1(self): super().grandfather() son1 = Son('xiaoming',18, 'male') son1.son_method1() 组合 1、组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合。 2、作用是可以将两个本来不相关的类联系起来。一般是两个类之间有显著的不同，很多时候还要附属关系(有相同的属性也有不同的属性)。比如人和头，手机和电池等等。 3、无纵向关系时用组合，有纵向关系时用继承。 4、组合就是一个类中使用到另一个类，从而把几个类拼到一起。组合的功能也是为了减少重复代码 多态 由不同的类实例化得到的对象，调用同一个方法，执行的逻辑不同 多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问，而不需考虑他们具体类。 多态表明了动态（又名，运行时）绑定的存在，允计重载及运行时类型确定和验证。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class People(object): def __init__(self, name, age): self.name = name self.age = age def generation(self): if self.age &lt; 18: print("[%s]属于未成年人" % self.name) elif 18 &lt; self.age &lt; 30: print("[%s]属于青年人" % self.name) else: print("[%s]属于中老年人" % self.name) class minor(People): pass class young(People): pass class old(People): pass def func(obj): obj.generation() w1 = young('luenci',20) w2 = minor('xiaoming', 16) w3 = old('jack', 50) func(w1) func(w3) func(w3) out: [luenci]属于青年人 [jack]属于中老年人 [jack]属于中老年人 反射 getattr(object, name) 得到属性的值 hasattr(object, name) 说明：判断对象object是否包含名为name的特性（hasattr是通过调用getattr(ojbect, name)是否抛出异常来实现的 setattr(object, name, value) 这是相对应的getattr()。参数是一个对象,一个字符串和一个任意值。字符串可能会列出一个现有的属性或一个新的属性。这个函数将值赋给属性的。该对象允许它提供。例如,setattr(x,“foobar”,123)相当于x.foobar= 123 delattr(object, name) 与setattr()相关的一组函数。参数是由一个对象(记住python中一切皆是对象)和一个字符串组成的。string参数必须是对象属性名之一。该函数删除该obj的一个由string指定的属性。delattr(x, 'foobar')=del x.foobar 注：getattr,hasattr,setattr,delattr对模块的修改都在内存中进行，并不会影响文件中真实内容。
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 5 min&nbsp|&nbsp📖字数: 2385 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Python面向对象" href=https://luenci.com/en/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>socket网络编程实战-斗鱼弹幕获取</h2></header><div class=entry-content><p>asyncore模块 介绍 这个模块为异步socket的服务器客户端通信提供简单的接口。
该模块提供了异步socket服务客户端和服务器的基础架构。
相比python原生的socket api，asyncore具备有很大的优势，asyncore对原生的socket进行封装，提供非常简洁优秀的接口，利用asyncore覆写相关需要处理的接口方法，就可以完成一个socket的网络编程，从而需要处理复杂的socket网络状况以及多线程处理等等。
实现流程 客户端 Socket 开发基本使用 1.定义类继承自asyncore.dispatcher
2.实现类中的回调代码
实现构造函数
调用父类方法 创建 Socket对象 连接服务器 实现handle_connect回调函数
当socket连接服务器成功时回调该函数
实现writable回调函数
描述是否有数据需要被发送到服务器。返回值为True表示可写，False表示不可写，如果不实现默认返回为True，当返回True时，回调函数handle_write将被触发
实现handle_write 回调函数
当有数据需要发送时（writable回调函数返回True时），该函数被触发，通常情况下在该函数中编写send方法发送数据
实现readable回调函数
描述是否有数据从服务端读取。返回True 表示有数据需要读取，False表示没有数据需要被读取，当不实现默认返回为True，当返回True 时，回调函数handle_read将被触发
实现handle_read 回调函数
当有数据需要读取时触发（readable回调函数返回True 时），该函数被触发，通常情况下在该函数中编写recv方法接收数据
实现handle_error回调函数
当程序运行过程发生异常时回调
实现handle_close回调函数
当连接被关闭时触发
3.创建对象并且执行asyncore.loop进入运行循环
timeout表示一次循环所需要的时长 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import asyncore import sys # 定义类继承自 asyncore.dispather class scoket_client(asyncore.dispatcher): # 实现类中的回调代码 def __init__(self, host, port): # 调用父类的方法 asyncore.dispatcher.__init__(self) # 创建 Scoket 服务器 self.create_socket() # 连接地址 address = (host, port) self.connect(address) pass # 实现handle_connect回调函数 def handle_connect(self): print("连接成功") # 实现writable函数 def writable(self): return False # 实现handle_write回调函数 def handle_write(self): # 内部实现对服务器发送数据代码 # 调用 send 方法发送数据，参数是字节数据 self.send("hello world".encode('utf-8')) # self.send("hello world") # 实现readable回调函数 def readable(self): return True # 实现handle_read回调函数 def handle_read(self): # 主动接收数据 result = self.recv(1024) print(result) # 实现handle_error回调函数 def handle_error(self): # 编写处理错误方法 t, e, trace = sys.exc_info() # 实现handle_close回调函数 def handle_close(self): print("连接关闭") self.close() # 创建对象并且执行asyncore.loop 进入循环 if __name__ == '__main__': client = scoket_client('127.0.0.1', 9000) # 开始启动运行循环 asyncore.loop(timeout=5) ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 5 min&nbsp|&nbsp📖字数: 2351 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to socket网络编程实战-斗鱼弹幕获取" href=https://luenci.com/en/posts/%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95%E6%8A%93%E5%8F%96/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SQL性能调优</h2></header><div class=entry-content><p>原文链接：https://blog.csdn.net/u010520146/article/details/81161762
一.创建索引 1.要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引 2.1在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。 2.2创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。 2.3一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。 二.避免在索引上使用计算 在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数 属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引。 效率低： select * from user where salary*22 > 11000 (salary是索引列)
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 6 min&nbsp|&nbsp📖字数: 2849 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to SQL性能调优" href=https://luenci.com/en/posts/sql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Vue.js的基本知识</h2></header><div class=entry-content><p>Vue.js概念 Vue.js 是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App，Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angularjs、Reactjs一起，并成为前端三大主流框架！· Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 后端中的MVC与前端中的MVVM之间的区别 MVC是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了三部分Model，View，VM ,ViewModel ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 14 min&nbsp|&nbsp📖字数: 6761 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to Vue.js的基本知识" href=https://luenci.com/en/posts/vue%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>windows 配置同时使用 Gitlab、Github、Gitee(码云) 共存的开发环境（转载）</h2></header><div class=entry-content><p>原文链接：https://blog.csdn.net/flowerspring/article/details/104962002
清除 git 的全局设置（针对已安装 git） 新安装 git 跳过。
若之前对 git 设置过全局的 user.name 和 user.email。 类似 (用 git config –global –list 进行查看你是否设置)
1 2 $ git config --global user.name "你的名字" $ git config --global user.email "你的邮箱" 必须删除该设置
1 2 $ git config --global --unset user.name "你的名字" $ git config --global --unset user.email "你的邮箱" 生成新的 SSH keys 1）Gitee 密钥 跳转到keygen目录，git bash here。
先键入第二行命令
第四行 指定 id 文件名称为id_rsa_gitee
第五、六行 设置无密码，直接回车两次。
会在keygen目录下生成文件 id_rsa_gitee 和 id_rsa_gitee.pub。
id_rsa_gitee.pub中存放的是公钥。
把公钥保存到gitee网页密钥中。
1 2 3 4 5 6 7 8 9 10 11 12 honey@honey MINGW64 /d/keygen $ ssh-keygen -t rsa -C yourmail@.com Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/honey/.ssh/id_rsa): id_rsa_gitee Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in id_rsa_gitee. Your public key has been saved in id_rsa_gitee.pub. The key fingerprint is: ... The key's randomart image is: ... 也可指定文件路径，方便后面操作：~/.ssh/id_rsa.gitlab ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C "yourmail@.com"
直接回车3下，什么也不要输入，就是默认没有密码。 注意 gitee 和 gitlab 的文件名是不同的。 ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 4 min&nbsp|&nbsp📖字数: 1696 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to windows 配置同时使用 Gitlab、Github、Gitee(码云) 共存的开发环境（转载）" href=https://luenci.com/en/posts/windows-%E9%85%8D%E7%BD%AE%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8-gitlabgithubgitee%E7%A0%81%E4%BA%91-%E5%85%B1%E5%AD%98%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>一些核心模块的介绍</h2></header><div class=entry-content><p>sys模块 模块方法 解释说明 sys.argv 传递到Python脚本的命令行参数列表，第一个元素是程序本身路径 sys.executable 返回Python解释器在当前系统中的绝对路径 sys.exit(arg) 程序中间的退出，arg=0为正常退出 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform 返回操作系统平台名称，Linux是linux2，Windows是win32 sys.stdout.write(str) 输出的时候把换行符\n去掉 val = sys.stdin.readline()[:-1] 拿到的值去掉\n换行符 sys.version 获取Python解释程序的版本信息 os模块 方法 说明 os.mkdir() 创建目录 os.rmdir() 删除目录 os.rename() 重命名 os.remove() 删除文件 os.getcwd() 获取当前工作路径 os.walk() 遍历目录 os.path.join() 连接目录与文件名 os.path.split() 分割文件名与目录 os.path.abspath() 获取绝对路径 os.path.dirname() 获取路径 os.path.basename() 获取文件名或文件夹名 os.path.splitext() 分离文件名与扩展名 os.path.isfile() 判断给出的路径是否是一个文件 os.path.isdir() 判断给出的路径是否是一个目录 json模块 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 8 min&nbsp|&nbsp📖字数: 3974 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 一些核心模块的介绍" href=https://luenci.com/en/posts/python%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BB%8B%E7%BB%8D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>京东全网爬虫</h2></header><div class=entry-content><p>完整代码见： https://github.com/Lucareful/JingDongSpider
写在前面：
折腾了很久的用python做爬虫项目到现在也该告一段落了，看视频学，遇到bug自己查找，代码思路不对重新写，环境不对自己配置….一路上跌跌撞撞，过程很艰苦，所幸结果为好。
...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 4 min&nbsp|&nbsp📖字数: 1890 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 京东全网爬虫" href=https://luenci.com/en/posts/%E4%BA%AC%E4%B8%9C%E5%85%A8%E7%BD%91%E7%88%AC%E8%99%AB/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>基于Python语言的IP代理池</h2></header><div class=entry-content><p>环境：python3.6
MongoDB
flask
requests等第三方库
完整代码见： https://github.com/Lucareful/IPProxyPool
代理池概述 什么是代理池 代理池就是有代理IP组成的池子，它可以提供多个稳定可用的代理IP 为什么要实现代理池 我们在做爬虫的时候，最常见的一种反爬虫手段就是：IP反爬；也就是当同一个IP访问这个网站的次数过多，频率过高，就会限制这个IP的访问。就是需要经常换IP；
使用IP代理池是其中一个比较常用的方案 免费代理都是非常不稳定的，有10%是可用就很不错了 一些收费代理稳定性也不好 目的：从一堆不稳定的代理IP中，抽取高可用代理IP，给爬虫使用
代理池开发环境 python3开发语言
requests：发送请求，获取页面数据
lxml：使用XPATH从页面提取我们想要的书籍
pymonge：把提取到代理IP存储到MongoDB数据库中和MongoDB数据库中读取代理IP，给爬虫使用
Flask：用于提供WEB服务
代理池工作流程 1.代理池工作渡程描述：
代理IP采集模块->采集代理IP->检测代理IP->如果不可用用，直接过滤掉，如果可用，指定默认分数->存入数据库中 代理IP检测模块->从数据库中获取所有代理IP->检测代理IP->如果代理IP不可用用，就把分数-1，如果分数为0从数据库中删除，否则更新数据库，如果代理IP可用，恢复为默认分值，更新数据库 代理API模块->从数据库中高可用的代理IP给爬虫使用； ...</p></div><footer class=entry-footer>📅最后更新:&nbsp;0001-01-01&nbsp|&nbsp⏲︎时长: 13 min&nbsp|&nbsp📖字数: 6061 words&nbsp;|&nbsp;Luenci</footer><a class=entry-link aria-label="post link to 基于Python语言的IP代理池" href=https://luenci.com/en/posts/ip%E4%BB%A3%E7%90%86%E6%B1%A0/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://luenci.com/en/posts/page/8/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://luenci.com/en/posts/page/10/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><script src=https://sdk.jinrishici.com/v2/browser/jinrishici.js></script><script type=text/javascript>jinrishici.load(function(e){var t=document.querySelector(".poem_sentence"),n=document.querySelector(".poem_info");t.innerHTML=e.data.content,n.innerHTML="—— "+e.data.origin.author})</script><span><a id=running-time></a><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container><link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>👁️‍🗨️访客人数: <span id=busuanzi_value_site_uv></span>|
🌐访问量: <span id=busuanzi_value_site_pv></span></span></span><br><span>&copy; 2026 <a href=https://luenci.com/en/>Luenci</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a> 📖
<text class=poem_sentence></text><text class=poem_info></text></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});const RunningTimerInterval=1e3,StartTime=new Date("10/11/2018 00:00:00");function prefixZero(e){return e<10&&(e="0"+e),e}function updateTime(){const r=new Date;let e=r.getTime()-StartTime.getTime();const t=24*60*60*1e3,n=Math.floor(e/t);e-=n*t;const s=60*60*1e3,o=Math.floor(e/s);e-=o*s;const i=60*1e3,a=Math.floor(e/i);e-=a*i;const c=Math.floor(e/1e3),l=document.getElementById("running-time");l.innerText="🕚: "+n+"天"+prefixZero(o)+"小时"+prefixZero(a)+"分"+prefixZero(c)+"秒"}document.addEventListener("DOMContentLoaded",()=>{let e=setInterval(updateTime,RunningTimerInterval)})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>