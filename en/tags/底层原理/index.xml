<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>底层原理 on Luenci</title>
    <link>https://luenci.com/en/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link>
    <description>Recent content in 底层原理 on Luenci</description>
    <generator>Hugo -- 0.145.0</generator>
    <language>en</language>
    <lastBuildDate>Sun, 07 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://luenci.com/en/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>浅谈Python垃圾回收机制</title>
      <link>https://luenci.com/en/posts/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 07 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://luenci.com/en/posts/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;目前垃圾回收比较通用的解决办法有三种，引用计数，标记清除以及分代回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;引用计数&#34;&gt;引用计数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引用计数也是一种最直观，最简单的垃圾收集技术。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在 Python 中，大多数对象的生命周期都是通过对象的引用计数来管理的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其原理非常简单，我们为每个对象维护一个 ref 的字段用来记录对象被引用的次数，每当对象被创建或者被引用时将该对象的引用次数加一，当对象的引用被销毁时该对象的引用次数减一，当对象的引用次数减到零时说明程序中已经没有任何对象持有该对象的引用，换言之就是在以后的程序运行中不会再次使用到该对象了，那么其所占用的空间也就可以被释放了了。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 1
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 2
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 3
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 4
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 5
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 6
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 7
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 8
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt; 9
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;10
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;11
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;12
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;13
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;14
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;15
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;16
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;17
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;18
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;19
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;20
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;21
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;22
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;23
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;24
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;25
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;26
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;27
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;28
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;29
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;30
&lt;/span&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff7b72&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#ff7b72&#34;&gt;os&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff7b72&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#ff7b72&#34;&gt;psutil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff7b72&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;print_memory_info&lt;/span&gt;(name):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a5d6ff&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a5d6ff&#34;&gt;    内存计算函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a5d6ff&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pid &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;.&lt;/span&gt;getpid()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; psutil&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;.&lt;/span&gt;Process(pid)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    info &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; p&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;.&lt;/span&gt;memory_full_info()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    MB &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;1024&lt;/span&gt; &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;1024&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memory &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; info&lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;.&lt;/span&gt;uss &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;/&lt;/span&gt; MB
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#a5d6ff&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#a5d6ff&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#a5d6ff&#34;&gt; used &lt;/span&gt;&lt;span style=&#34;color:#a5d6ff&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#a5d6ff&#34;&gt; MB&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;%&lt;/span&gt; (name, memory))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff7b72&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#d2a8ff;font-weight:bold&#34;&gt;test&lt;/span&gt;(): 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_memory_info(&lt;span style=&#34;color:#a5d6ff&#34;&gt;&amp;#39;test start&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    length &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;1000&lt;/span&gt; &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a5d6ff&#34;&gt;1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    list1 &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; [i &lt;span style=&#34;color:#ff7b72&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;in&lt;/span&gt; range(length)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print_memory_info(&lt;span style=&#34;color:#a5d6ff&#34;&gt;&amp;#39;test end&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff7b72&#34;&gt;return&lt;/span&gt; list1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;res &lt;span style=&#34;color:#ff7b72;font-weight:bold&#34;&gt;=&lt;/span&gt; test()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print_memory_info(&lt;span style=&#34;color:#a5d6ff&#34;&gt;&amp;#34;main end&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;out:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    test start used &lt;span style=&#34;color:#a5d6ff&#34;&gt;4&lt;/span&gt; MB
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	test end used &lt;span style=&#34;color:#a5d6ff&#34;&gt;23&lt;/span&gt; MB
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	main end used &lt;span style=&#34;color:#a5d6ff&#34;&gt;23&lt;/span&gt; MB
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由上述例子：如下情况会存在引用计数加一&lt;/p&gt;</description>
      <content:encoded><![CDATA[<ul>
<li>目前垃圾回收比较通用的解决办法有三种，引用计数，标记清除以及分代回收。</li>
</ul>
<h2 id="引用计数">引用计数</h2>
<ul>
<li>引用计数也是一种最直观，最简单的垃圾收集技术。</li>
<li><strong>在 Python 中，大多数对象的生命周期都是通过对象的引用计数来管理的。</strong></li>
<li>其原理非常简单，我们为每个对象维护一个 ref 的字段用来记录对象被引用的次数，每当对象被创建或者被引用时将该对象的引用次数加一，当对象的引用被销毁时该对象的引用次数减一，当对象的引用次数减到零时说明程序中已经没有任何对象持有该对象的引用，换言之就是在以后的程序运行中不会再次使用到该对象了，那么其所占用的空间也就可以被释放了了。</li>
</ul>
<div class="highlight"><div style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">31
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff7b72">import</span> <span style="color:#ff7b72">os</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">import</span> <span style="color:#ff7b72">psutil</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">print_memory_info</span>(name):
</span></span><span style="display:flex;"><span>    <span style="color:#a5d6ff">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#a5d6ff">    内存计算函数
</span></span></span><span style="display:flex;"><span><span style="color:#a5d6ff">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    pid <span style="color:#ff7b72;font-weight:bold">=</span> os<span style="color:#ff7b72;font-weight:bold">.</span>getpid()
</span></span><span style="display:flex;"><span>    p <span style="color:#ff7b72;font-weight:bold">=</span> psutil<span style="color:#ff7b72;font-weight:bold">.</span>Process(pid)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    info <span style="color:#ff7b72;font-weight:bold">=</span> p<span style="color:#ff7b72;font-weight:bold">.</span>memory_full_info()
</span></span><span style="display:flex;"><span>    MB <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">1024</span> <span style="color:#ff7b72;font-weight:bold">*</span> <span style="color:#a5d6ff">1024</span>
</span></span><span style="display:flex;"><span>    memory <span style="color:#ff7b72;font-weight:bold">=</span> info<span style="color:#ff7b72;font-weight:bold">.</span>uss <span style="color:#ff7b72;font-weight:bold">/</span> MB
</span></span><span style="display:flex;"><span>    print(<span style="color:#a5d6ff">&#39;</span><span style="color:#a5d6ff">%s</span><span style="color:#a5d6ff"> used </span><span style="color:#a5d6ff">%d</span><span style="color:#a5d6ff"> MB&#39;</span> <span style="color:#ff7b72;font-weight:bold">%</span> (name, memory))
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">test</span>(): 
</span></span><span style="display:flex;"><span>    print_memory_info(<span style="color:#a5d6ff">&#39;test start&#39;</span>)
</span></span><span style="display:flex;"><span>    length <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">1000</span> <span style="color:#ff7b72;font-weight:bold">*</span> <span style="color:#a5d6ff">1000</span>
</span></span><span style="display:flex;"><span>    list1 <span style="color:#ff7b72;font-weight:bold">=</span> [i <span style="color:#ff7b72">for</span> i <span style="color:#ff7b72;font-weight:bold">in</span> range(length)]
</span></span><span style="display:flex;"><span>    print_memory_info(<span style="color:#a5d6ff">&#39;test end&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">return</span> list1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>res <span style="color:#ff7b72;font-weight:bold">=</span> test()
</span></span><span style="display:flex;"><span>print_memory_info(<span style="color:#a5d6ff">&#34;main end&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>    test start used <span style="color:#a5d6ff">4</span> MB
</span></span><span style="display:flex;"><span>	test end used <span style="color:#a5d6ff">23</span> MB
</span></span><span style="display:flex;"><span>	main end used <span style="color:#a5d6ff">23</span> MB
</span></span></code></pre></td></tr></table>
</div>
</div><p>由上述例子：如下情况会存在引用计数加一</p>
<ul>
<li>对象被创建（num=2）</li>
<li>对象被引用（count=num）</li>
<li>对象作为参数传递到函数内部</li>
<li>对象作为一个元素添加到容器中</li>
</ul>
<p>而如下情况会导致引用次数减一：</p>
<ul>
<li>对象的别名被显式销毁（del num）</li>
<li>对象的别名被赋予新的对象（num=30）</li>
<li>对象离开它的作用域（函数局部变量）</li>
<li>从容器中删除对象，或者容器被销毁</li>
</ul>
<p>引用计数的不足：</p>
<div class="highlight"><div style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">test</span>():
</span></span><span style="display:flex;"><span>    print_memory_info(<span style="color:#a5d6ff">&#34;foo start&#34;</span>)
</span></span><span style="display:flex;"><span>    length <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">1000</span> <span style="color:#ff7b72;font-weight:bold">*</span> <span style="color:#a5d6ff">1000</span>
</span></span><span style="display:flex;"><span>    list_a <span style="color:#ff7b72;font-weight:bold">=</span> [i <span style="color:#ff7b72">for</span> i <span style="color:#ff7b72;font-weight:bold">in</span> range(length)]
</span></span><span style="display:flex;"><span>    list_b <span style="color:#ff7b72;font-weight:bold">=</span> [i <span style="color:#ff7b72">for</span> i <span style="color:#ff7b72;font-weight:bold">in</span> range(length)]
</span></span><span style="display:flex;"><span>    list_a<span style="color:#ff7b72;font-weight:bold">.</span>append(list_b)
</span></span><span style="display:flex;"><span>    list_b<span style="color:#ff7b72;font-weight:bold">.</span>append(list_a)
</span></span><span style="display:flex;"><span>    print_memory_info(<span style="color:#a5d6ff">&#34;foo end&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>out:
</span></span><span style="display:flex;"><span>    test start used <span style="color:#a5d6ff">4</span> MB
</span></span><span style="display:flex;"><span>	test end used <span style="color:#a5d6ff">42</span> MB
</span></span><span style="display:flex;"><span>	main end used <span style="color:#a5d6ff">42</span> MB
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析：</p>
<blockquote>
<p>在函数 test内部生成了两个列表 list_a 和 list_b，然后将两个列表分别添加到另外一个中。由结果可以看出，即使 foo 函数结束之后其所占用的内存空间依然未被释放。这是因为对于 list_a 和 list_b 来说虽然没有被任何外部对象引用，但因为二者之间交叉引用，以至于每个对象的引用计数都不为零，这也就造成了其所占用的空间永远不会被回收的尴尬局面。这个缺点是致命的。</p></blockquote>
<p><strong>为了解决交叉引用的问题，Python 引入了标记清除算法和分代回收算法。</strong></p>
<!-- more -->
<h2 id="标记清除">标记清除</h2>
<ul>
<li>
<p>由上，可以包含其他对象引用的容器对象都有可能产生交叉引用问题，而标记清除算法就是为了解决交叉引用的问题的。</p>
</li>
<li>
<p>标记清除（Mark—Sweep）算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：</p>
<ul>
<li>第一阶段是标记阶段，GC会把所有的活动对象打上标记</li>
<li>第二阶段是把那些没有标记的对象非活动对象进行回收。</li>
</ul>
<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p>
<p><img loading="lazy" src="https://foofish.net/images/mark-sweep.svg" alt="img"  />
</p>
<p>在上图中，可以从程序变量直接访问块1，并且可以间接访问块2和3。程序无法访问块4和5。第一步将标记块1，并记住块2和3以供稍后处理。第二步将标记块2，第三步将标记块3，但不记得块2，因为它已被标记。扫描阶段将忽略块1，2和3，因为它们已被标记，但会回收块4和5。</p>
<p>标记清除算法作为Python的辅助垃圾收集技术，主要处理的是一些容器对象，比如list、dict、tuple等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。</p>
<blockquote>
<p>不过，这种简单粗暴的标记清除算法也有明显的缺点：<strong>清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</strong></p></blockquote>
</li>
</ul>
<h2 id="分代回收">分代回收</h2>
<blockquote>
<p>分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。</p></blockquote>
<ul>
<li>由于标记清除算法需要扫描整个堆的所有对象导致其性能有所损耗，而且当可以回收的对象越少时性能损耗越高。因此 Python 引入了分代回收算法，将系统中存活时间不同的对象划分到不同的内存区域，共三代，分别是 0 代，1 代 和 2 代。新生成的对象是 0 代，经过一次垃圾回收之后，还存活的对象将会升级到 1 代，以此类推，2 代中的对象是存活最久的对象。</li>
</ul>
<p>那么什么时候触发进行垃圾回收算法呢 ?</p>
<ul>
<li>
<p>事实上随着程序的运行会不断的创建新的对象，同时也会因为引用计数为零而销毁大部分对象，Python 会保持对这些对象的跟踪，由于交叉引用的存在，以及程序中使用了长时间存活的对象，这就造成了新生成的对象的数量会大于被回收的对象数量，一旦二者之间的差值达到某个阈值就会启动垃圾回收机制，使用标记清除算法将死亡对象进行清除，同时将存活对象移动到 1 代。 以此类推，当二者的差值再次达到阈值时又触发垃圾回收机制，将存活对象移动到 2 代。</p>
</li>
<li>
<p>这样通过对不同代的阈值做不同的设置，就可以做到在不同代使用不同的时间间隔进行垃圾回收，以追求性能最大。</p>
</li>
</ul>
<p>事实上，所有的程序都有一个相同的现象，那就是大部分的对象生存周期都是相当短的，只有少量对象生命周期比较长，甚至会常驻内存，从程序开始运行持续到程序结束。而通过分代回收算法，做到了针对不同的区域采取不同的回收频率，节约了大量的计算从而提高 Python 的性能。</p>
<p>除了上面所说的差值达到一定<strong>阈值</strong>会触发垃圾回收之外，<strong>我们还可以显式的调用 <code>gc.collect()</code> 来触发垃圾回收，最后当程序退出时也会进行垃圾回收</strong>。</p>
<h1 id="python的gc模块">python的gc模块</h1>
<h2 id="gc--垃圾回收器接口"><a href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc"><code>gc</code></a> &mdash; 垃圾回收器接口</h2>
<hr>
<ul>
<li>此模块提供可选的垃圾回收器的接口，提供的功能包括：
<ul>
<li>关闭收集器、调整收集频率、设置调试选项。</li>
</ul>
</li>
<li>它同时提供对回收器找到但是无法释放的不可达对象的访问。<strong>由于 Python 使用了带有引用计数的回收器</strong>，如果你确定你的程序不会产生循环引用，你可以关闭回收器。可以通过调用 <code>gc.disable()</code> 关闭自动垃圾回收。若要调试一个存在内存泄漏的程序，调用 <code>gc.set_debug(gc.DEBUG_LEAK)</code> ；需要注意的是，它包含 <code>gc.DEBUG_SAVEALL</code> ，使得被垃圾回收的对象会被存放在<code> gc.garbage</code> 中以待检查。</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc"><code>gc</code></a> 模块提供下列函数：</p>
<ul>
<li>
<p><code>gc.enable</code>()</p>
<p>启用自动垃圾回收</p>
</li>
<li>
<p><code>gc.disable</code>()</p>
<p>停用自动垃圾回收</p>
</li>
<li>
<p><code>gc.isenabled</code>()</p>
<p>如果启用了自动回收则返回 <code>True</code>。</p>
</li>
<li>
<p><code>gc.collect</code>(<em>generation=2</em>)</p>
<p>若被调用时不包含参数，则启动完全的垃圾回收。可选的参数 <em>generation</em> 可以是一个整数，指明需要回收哪一代（从 0 到 2 ）的垃圾。当参数 <em>generation</em> 无效时，会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError"><code>ValueError</code></a> 异常。返回发现的不可达对象的数目。每当运行完整收集或最高代 (2) 收集时，为多个内置类型所维护的空闲列表会被清空。 由于特定类型特别是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float"><code>float</code></a> 的实现，在某些空闲列表中并非所有项都会被释放。</p>
</li>
<li>
<p><code>gc.set_debug</code>(<em>flags</em>)</p>
<p>设置垃圾回收器的调试标识位。调试信息会被写入 <code>sys.stderr</code> 。此文档末尾列出了各个标志位及其含义；可以使用位操作对多个标志位进行设置以控制调试器。</p>
</li>
<li>
<p><code>gc.get_debug</code>()</p>
<p>返回当前调试标识位。</p>
</li>
<li>
<p><code>gc.get_objects</code>(<em>generation=None</em>)</p>
<p>返回一个收集器所跟踪的所有对象的列表，所返回的列表除外。 如果 <em>generation</em> 不为 None，则只返回收集器所跟踪的属于该生成的对象。<em>在 3.8 版更改:</em> 新的 <em>generation</em> 形参。</p>
</li>
<li>
<p><code>gc.get_stats</code>()</p>
<p>返回一个包含三个字典对象的列表，每个字典分别包含对应代的从解释器开始运行的垃圾回收统计数据。字典的键的数目在将来可能发生改变，目前每个字典包含以下内容：<code>collections</code> 是该代被回收的次数；<code>collected</code> 是该代中被回收的对象总数；<code>uncollectable</code> 是在这一代中被发现无法收集的对象总数 （因此被移动到 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>garbage</code></a> 列表中）。<em>3.4 新版功能.</em></p>
</li>
<li>
<p><code>gc.set_threshold</code>(<em>threshold0</em>[, <em>threshold1</em>[, <em>threshold2</em>]])</p>
<p>设置垃圾回收阈值（收集频率）。 将 <em>threshold0</em> 设为零会禁用回收。垃圾回收器把所有对象分类为三代，取决于对象幸存于多少次垃圾回收。新创建的对象会被放在最年轻代（第 <code>0</code> 代）。如果一个对象幸存于一次垃圾回收，则该对象会被放入下一代。第 <code>2</code> 代是最老的一代，因此这一代的对象幸存于垃圾回收后，仍会留在第 <code>2</code> 代。为了判定何时需要进行垃圾回收，垃圾回收器会跟踪上一次回收后，分配和释放的对象的数目。当分配对象的数量减去释放对象的数量大于阈值 <em>threshold0</em> 时，回收器开始进行垃圾回收。起初只有第 <code>0</code> 代会被检查。当上一次第 <code>1</code> 代被检查后，第 <code>0</code> 代被检查的次数多于阈值 <em>threshold1</em> 时，第 <code>1</code> 代也会被检查。相似的， <em>threshold2</em> 设置了触发第 <code>2</code> 代被垃圾回收的第 <code>1</code> 代被垃圾回收的次数。</p>
</li>
<li>
<p><code>gc.get_count</code>()</p>
<p>将当前回收计数以形为 <code>(count0, count1, count2)</code> 的元组返回。</p>
</li>
<li>
<p><code>gc.get_threshold</code>()</p>
<p>将当前回收阈值以形为 <code>(threshold0, threshold1, threshold2)</code> 的元组返回。</p>
</li>
<li>
<p><code>gc.get_referrers</code>(*<em>objs</em>)</p>
<p>返回直接引用任意一个 <em>ojbs</em> 的对象列表。这个函数只定位支持垃圾回收的容器；引用了其它对象但不支持垃圾回收的扩展类型不会被找到。需要注意的是，已经解除对 <em>objs</em> 引用的对象，但仍存在于循环引用中未被回收时，仍然会被作为引用者出现在返回的列表当中。若要获取当前正在引用 <em>objs</em> 的对象，需要调用 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.collect"><code>collect()</code></a> 然后再调用 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.get_referrers"><code>get_referrers()</code></a> 。在使用 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.get_referrers"><code>get_referrers()</code></a> 返回的对象时必须要小心，因为其中一些对象可能仍在构造中因此处于暂时的无效状态。不要把 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.get_referrers"><code>get_referrers()</code></a> 用于调试以外的其它目的。</p>
</li>
<li>
<p><code>gc.get_referents</code>(*<em>objs</em>)</p>
<p>返回被任意一个参数中的对象直接引用的对象的列表。返回的被引用对象是被参数中的对象的C语言级别方法（若存在） <a href="https://docs.python.org/zh-cn/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse"><code>tp_traverse</code></a> 访问到的对象，可能不是所有的实际直接可达对象。只有支持垃圾回收的对象支持 <a href="https://docs.python.org/zh-cn/3/c-api/typeobj.html#c.PyTypeObject.tp_traverse"><code>tp_traverse</code></a> 方法，并且此方法只会在需要访问涉及循环引用的对象时使用。因此，可以有以下例子：一个整数对其中一个参数是直接可达的，这个整数有可能出现或不出现在返回的结果列表当中。</p>
</li>
<li>
<p><code>gc.is_tracked</code>(<em>obj</em>)</p>
<p>当对象正在被垃圾回收器监控时返回 <code>True</code> ，否则返回 <code>False</code> 。一般来说，原子类的实例不会被监控，而非原子类（如容器、用户自定义的对象）会被监控。然而，会有一些特定类型的优化以便减少垃圾回收器在简单实例（如只含有原子性的键和值的字典）上的消耗。&raquo;&gt;<code>&gt;&gt;&gt; gc.is_tracked(0) False &gt;&gt;&gt; gc.is_tracked(&quot;a&quot;) False &gt;&gt;&gt; gc.is_tracked([]) True &gt;&gt;&gt; gc.is_tracked({}) False &gt;&gt;&gt; gc.is_tracked({&quot;a&quot;: 1}) False &gt;&gt;&gt; gc.is_tracked({&quot;a&quot;: []}) True </code><em>3.1 新版功能.</em></p>
</li>
<li>
<p><code>gc.freeze</code>()</p>
<p>冻结 gc 所跟踪的所有对象 —— 将它们移至永久代并忽略所有未来的集合。 这可以在 POSIX fork() 调用之前使用以便令对写入复制保持友好或加速收集。 并且在 POSIX fork() 调用之前的收集也可以释放页面以供未来分配，这也可能导致写入时复制，因此建议在主进程中禁用 gc 并在 fork 之前冻结，而在子进程中启用 gc。<em>3.7 新版功能.</em></p>
</li>
<li>
<p><code>gc.unfreeze</code>()</p>
<p>解冻永久代中的对象，并将它们放回到年老代中。<em>3.7 新版功能.</em></p>
</li>
<li>
<p><code>gc.get_freeze_count</code>()</p>
<p>返回永久代中的对象数量。<em>3.7 新版功能.</em></p>
</li>
</ul>
<p>提供以下变量仅供只读访问（你可以修改但不应该重绑定它们）：</p>
<ul>
<li>
<p><code>gc.garbage</code></p>
<p>一个回收器发现不可达而又无法被释放的对象（不可回收对象）列表。 从 Python 3.4 开始，该列表在大多数时候都应该是空的，除非使用了含有非 <code>NULL</code> <code>tp_del</code> 空位的 C 扩展类型的实例。如果设置了 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.DEBUG_SAVEALL"><code>DEBUG_SAVEALL</code></a> ，则所有不可访问对象将被添加至该列表而不会被释放。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-interpreter-shutdown">interpreter shutdown</a> 即解释器关闭时，若此列表非空，会产生 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ResourceWarning"><code>ResourceWarning</code></a> ，即资源警告，在默认情况下此警告不会被提醒。如果设置了 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.DEBUG_UNCOLLECTABLE"><code>DEBUG_UNCOLLECTABLE</code></a> ，所有无法被回收的对象会被打印。<em>在 3.4 版更改:</em> 根据 <a href="https://www.python.org/dev/peps/pep-0442"><strong>PEP 442</strong></a> ，带有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__"><code>__del__()</code></a> 方法的对象最终不再会进入 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>gc.garbage</code></a> 。</p>
</li>
<li>
<p><code>gc.callbacks</code></p>
<p>在垃圾回收器开始前和完成后会被调用的一系列回调函数。这些回调函数在被调用时使用两个参数： <em>phase</em> 和 <em>info</em> 。<em>phase</em> 可为以下两值之一：&ldquo;start&rdquo;: 垃圾回收即将开始。&ldquo;sweight&rdquo;: 垃圾回收已结束。<em>info</em> is a dict providing more information for the callback. The following keys are currently defined:&ldquo;generation&rdquo;（代） ：正在被回收的最久远的一代。&ldquo;collected&rdquo;（已回收的 ）: 当<em>phase</em> 为 &ldquo;sweight&rdquo; 时，被成功回收的对象的数目。&ldquo;uncollectable&rdquo;（不可回收的）: 当 <em>phase</em> 为 &ldquo;sweight&rdquo; 时，不能被回收并被放入 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>garbage</code></a> 的对象的数目。应用程序可以把他们自己的回调函数加入此列表。主要的使用场景有：统计垃圾回收的数据，如：不同代的回收频率、回收所花费的时间。使应用程序可以识别和清理他们自己的在 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>garbage</code></a> 中的不可回收类型的对象。<em>3.3 新版功能.</em></p>
</li>
</ul>
<p>以下常量被用于 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.set_debug"><code>set_debug()</code></a> ：</p>
<ul>
<li>
<p><code>gc.DEBUG_STATS</code></p>
<p>在回收完成后打印统计信息。当回收频率设置较高时，这些信息会比较有用。</p>
</li>
<li>
<p><code>gc.DEBUG_COLLECTABLE</code></p>
<p>当发现可回收对象时打印信息。</p>
</li>
<li>
<p><code>gc.DEBUG_UNCOLLECTABLE</code></p>
<p>打印找到的不可回收对象的信息（指不能被回收器回收的不可达对象）。这些对象会被添加到 <code>garbage</code> 列表中。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-interpreter-shutdown">interpreter shutdown</a> 时，即解释器关闭时，若 <a href="https://docs.python.org/zh-cn/3/library/gc.html#gc.garbage"><code>garbage</code></a> 列表中存在对象，这些对象也会被打印输出。</p>
</li>
<li>
<p><code>gc.DEBUG_SAVEALL</code></p>
<p>设置后，所有回收器找到的不可达对象会被添加进 <em>garbage</em> 而不是直接被释放。这在调试一个内存泄漏的程序时会很有用。</p>
</li>
<li>
<p><code>gc.DEBUG_LEAK</code></p>
<p>调试内存泄漏的程序时，使回收器打印信息的调试标识位。（等价于 <code>DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL</code> ）。</p>
</li>
</ul>
<blockquote>
<p>参考文章：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/gc.html">https://docs.python.org/zh-cn/3/library/gc.html</a></p>
<p><a href="http://www.ityouknow.com/python/2020/01/06/python-gc-111.html">http://www.ityouknow.com/python/2020/01/06/python-gc-111.html</a></p>
<p><a href="http://www.bieryun.com/5338.html">http://www.bieryun.com/5338.html</a></p></blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>list, tuple, dictionary, set的底层细节（python）</title>
      <link>https://luenci.com/en/posts/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://luenci.com/en/posts/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h1 id=&#34;list-tuple-dictionary-set的底层细节&#34;&gt;list, tuple, dictionary, set的底层细节&lt;/h1&gt;
&lt;h2 id=&#34;列表实现细节&#34;&gt;列表实现细节&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;python中的列表的英文名是list，因此很容易和其它语言(C++, Java等)标准库中常见的链表混淆。事实上CPython的列表根本不是列表（可能换成英文理解起来容易些：python中的list不是list）。在CPython中，列表被实现为长度可变的数组。&lt;strong&gt;可参考《Python高级编程（第2版）》&lt;/strong&gt;&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="list-tuple-dictionary-set的底层细节">list, tuple, dictionary, set的底层细节</h1>
<h2 id="列表实现细节">列表实现细节</h2>
<ul>
<li>
<p>python中的列表的英文名是list，因此很容易和其它语言(C++, Java等)标准库中常见的链表混淆。事实上CPython的列表根本不是列表（可能换成英文理解起来容易些：python中的list不是list）。在CPython中，列表被实现为长度可变的数组。<strong>可参考《Python高级编程（第2版）》</strong></p>
</li>
<li>
<p>从细节上看，Python中的列表是由对其它对象的引用组成的连续数组。指向这个数组的指针及其长度被保存在一个列表头结构中。</p>
</li>
<li>
<p>这意味着，每次添加或删除一个元素时，由引用组成的数组需要该标大小（重新分配）。幸运的是，Python在创建这些数组时采用了指数分配，所以并不是每次操作都需要改变数组的大小。但是，也因为这个原因添加或取出元素的平摊复杂度较低。不幸的是，在普通链表上“代价很小”的其它一些操作在Python中计算复杂度相对过高。</p>
<p><strong>利用 list.insert(i,item) 方法在任意位置插入一个元素——复杂度O(N)</strong>
<strong>利用 list.pop(i) 或 list.remove(value) 删除一个元素——复杂度O(N)</strong></p>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>操作</th>
          <th>复杂度</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>复制</td>
          <td>O(N)</td>
      </tr>
      <tr>
          <td>添加元素(在尾部添加)</td>
          <td>O(1)</td>
      </tr>
      <tr>
          <td>插入元素(在指定位置插入)</td>
          <td>O(N)</td>
      </tr>
      <tr>
          <td>获取元素</td>
          <td>O(1)</td>
      </tr>
      <tr>
          <td>修改元素</td>
          <td>O(1)</td>
      </tr>
      <tr>
          <td>删除元素</td>
          <td>O(N)</td>
      </tr>
      <tr>
          <td>遍历</td>
          <td>O(N)</td>
      </tr>
      <tr>
          <td>获取长度为k的切片</td>
          <td>O(k)</td>
      </tr>
      <tr>
          <td>删除切片</td>
          <td>O(N)</td>
      </tr>
      <tr>
          <td>列表扩展</td>
          <td>O(k)</td>
      </tr>
      <tr>
          <td>测试是否在列表中</td>
          <td>O(N)</td>
      </tr>
      <tr>
          <td>min()/max()</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>获取列表长度</td>
          <td>O(1)</td>
      </tr>
  </tbody>
</table>
<h2 id="字典实现细节">字典实现细节</h2>
<ul>
<li>
<p>CPython使用伪随机探测(pseudo-random probing)的散列表(hash table)作为字典的底层数据结构。由于这个实现细节，只有可哈希的对象才能作为字典的键。</p>
</li>
<li>
<p><strong>Python中所有不可变的内置类型都是可哈希的</strong>。可变类型（如列表，字典和集合）就是不可哈希的，因此不能作为字典的键。</p>
</li>
<li>
<p>字典的三个基本操作（添加元素，获取元素和删除元素）的平均事件复杂度为O(1)，但是他们的平摊最坏情况复杂度要高得多，为O(N).</p>
</li>
<li>
<p>字典的三个基本操作（添加元素，获取元素和删除元素）的平均事件复杂度为O(1)，但是他们的平摊最坏情况复杂度要高得多，为O(N).</p>
<table>
  <thead>
      <tr>
          <th>操作</th>
          <th>平均复杂度</th>
          <th>平摊最坏情况复杂度</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>获取元素</td>
          <td>O(1)</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>修改元素</td>
          <td>O(1)</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>删除元素</td>
          <td>O(1)</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>复制</td>
          <td>O(n)</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>遍历</td>
          <td>O(n)</td>
          <td>O(n)</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>还有一点很重要，<strong>在复制和遍历字典的操作中，最坏的复杂度中的n是字典曾经达到的最大元素数目</strong>，而不是当前的元素数目。换句话说，如果一个字典曾经元素个数很多，后来又大大减小了，那么遍历这个字典可能会花费相当长的事件。因此在某些情况下，如果需要频繁的遍历某个词典，那么最好创建一个新的字典对象，而不是仅在旧字典中删除元素。</p>
</li>
</ul>
<!-- more -->
<h2 id="集合实现细节">集合实现细节</h2>
<ul>
<li>
<p>集合是一种鲁棒性很好的数据结构，当元素顺序的重要性不如元素的唯一性和测试元素是否包含在集合中的效率时，大部分情况下这种数据结构极其有用。</p>
</li>
<li>
<p>python的内置集合类型有两种：</p>
</li>
<li>
<p>set(): 一种可变的、无序的、有限的集合，其元素是唯一的、不可变的（可哈希的）对象。</p>
</li>
<li>
<p>frozenset(): 一种不可变的、可哈希的、无序的集合，其元素是唯一的，不可变的哈希对象。</p>
</li>
<li>
<p>CPython中集合和字典非常相似。事实上，集合被实现为带有空值的字典，只有键才是实际的集合元素。此外，集合还利用这种没有值的映射做了其它的优化。</p>
</li>
<li>
<p>由于这一点，可以快速的向集合中添加元素、删除元素、检查元素是否存在。平均时间复杂度为O(1),最坏的事件复杂度是O(n)。</p>
</li>
</ul>
<h1 id="哈希函数">哈希函数</h1>
<ul>
<li>哈希函数就是一个映射，因此哈希函数的设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许的范围之内即可；</li>
<li>并不是所有的输入都只对应唯一一个输出，也就是哈希函数不可能做成一个一对一的映射关系，其本质是一个多对一的映射，这也就引出了下面一个概念–冲突。</li>
</ul>
<p>只要不是一对一的映射关系，冲突就必然会发生</p>
<h2 id="冲突解决方法python所使用的开放地址">冲突解决方法（python所使用的）开放地址</h2>
<h4 id="线性探测再散列">线性探测再散列</h4>
<p>例如  哈希函数为： H（key） =  key %11,key 为关键字，采用开放地址法中的线性探测再散列解决冲突，依次输入</p>
<p>9 个关键字，19，01，23，14，55，68，11，82，36，构造哈希表（表长=11）</p>
<table>
  <thead>
      <tr>
          <th>散列地址</th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>10</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>关键字</td>
          <td>55</td>
          <td>01</td>
          <td>23</td>
          <td>14</td>
          <td>68</td>
          <td>11</td>
          <td>82</td>
          <td>36</td>
          <td>19</td>
          <td></td>
          <td></td>
      </tr>
      <tr>
          <td>探测次数</td>
          <td>1</td>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>3</td>
          <td>6</td>
          <td>2</td>
          <td>5</td>
          <td>1</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>如上表，例如 14%11=3，将14放入3号位置，11%11 = 0，将11放入0号位置，而此时3号位已经有元素。</p>
<p>就顺着表往后放，直到5号没有元素，11放入5号。</p>
<h4 id="二次探测再散列">二次探测再散列</h4>
<p>例如  哈希函数为： H（key） =  key %11,key 为关键字，采用开放地址法中的二次探测再散列解决冲突，依次输入</p>
<p>9 个关键字，19，01，23，14，55，68，11，82，36，构造哈希表（表长=11）</p>
<table>
  <thead>
      <tr>
          <th>散列地址</th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>10</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>关键字</td>
          <td>55</td>
          <td>01</td>
          <td>23</td>
          <td>14</td>
          <td>36</td>
          <td>82</td>
          <td>68</td>
          <td></td>
          <td>19</td>
          <td></td>
          <td>11</td>
      </tr>
      <tr>
          <td>探测次数</td>
          <td>1</td>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>4</td>
          <td></td>
          <td>1</td>
          <td></td>
          <td>3</td>
      </tr>
  </tbody>
</table>
<p>对于01%11=1，将01放入1号位置， 11%11=0，此时0号位置已经有元素，</p>
<p>则查找 0 + 1^2 = 1,有元素</p>
<p>查找 0 - 1^2 = -1 ,没有则放入，如果还有元素则查找0 + 2^2, 0-2^2&hellip;. 0+k^2, 0 - k^2。</p>
<h1 id="扩展哈希冲突解决方法">扩展（哈希冲突解决方法）</h1>
<h2 id="开放地址">开放地址</h2>
<p>开放地址的意思是<strong>除了哈希函数得出的地址可用，当出现冲突的时候其他的地址也一样可用</strong>，常见的开放地址思想的方法有线性探测再散列，二次探测再散列，这些方法都是在第一选择被占用的情况下的解决方法。</p>
<h2 id="再哈希法">再哈希法</h2>
<p>这个方法是按顺序规定多个哈希函数，每次查询的时候按顺序调用哈希函数，调用到第一个为空的时候返回不存在，调用到此键的时候返回其值。</p>
<h2 id="链地址法">链地址法</h2>
<p><strong>将所有关键字哈希值相同的记录都存在同一线性链表中</strong>，这样不需要占用其他的哈希地址，相同的哈希值在一条链表上，按顺序遍历就可以找到。</p>
<h2 id="公共溢出区">公共溢出区</h2>
<p>其基本思想是：所有关键字和基本表中关键字为相同哈希值的记录，不管他们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。</p>
<h2 id="装填因子α">装填因子α</h2>
<p>一般情况下，处理冲突方法相同的哈希表，其平均查找长度依赖于哈希表的装填因子。哈希表的装填因子定义为表中填入的记录数和哈希表长度的壁纸，也就是<strong>标志着哈希表的装满程度</strong>。直观看来，<strong>α越小，发生冲突的可能性就越小，反之越大。一般0.75比较合适</strong>，涉及数学推导。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
